# Ansible Role: Letsencrypt GoDaddy

**Table of Contents**

* [Overview](#overview)
* [Supported Operating Systems/Platforms](#supported-operating-systemsplatforms)
* [Role Variables](#role-variables)
* [Tags](#tags)
* [Dependencies](#dependencies)
* [Example Playbook](#example-playbook)
* [Testing Instructions](#testing-instructions)
* [Known Issues and Gotchas](#known-issues-and-gotchas)
* [Security Implications](#security-implications)
* [Cross-Referencing](#cross-referencing)

## Overview

The **letsencrypt_godaddy** role automates obtaining and renewing SSL/TLS certificates from **Let’s Encrypt** using the DNS-01 challenge method with **GoDaddy** as the DNS provider. It installs the lightweight **acme.sh** client on your server to handle ACME interactions, leverages GoDaddy’s API to create the necessary DNS verification records, and deploys the resulting certificate and key to your system. This allows you to secure your websites or services with trusted certificates without manual steps. Key features include:

* **DNS-01 Challenge Automation:** No need to open ports or stop web services for HTTP challenges. The role uses GoDaddy’s DNS API to create the required `_acme-challenge` TXT record for domain validation, enabling certificate issuance even for hosts that are not publicly accessible or for **wildcard certificates**.
* **Multiple Domains & Wildcards:** You can request certificates for one or multiple domains (SAN certificates) including wildcard domains (e.g. `*.example.com`). The first domain in the list is treated as the primary domain for the certificate. All specified domains will be covered by a single certificate.
* **Automatic Renewal:** By default, the role sets up a cron job to automatically renew certificates before they expire. The **acme.sh** client will regularly check and renew certificates as needed, so your certificates stay up-to-date without manual intervention.
* **Idempotent & Safe Re-runs:** Re-running the role will not request new certificates unless needed. If a valid certificate for the requested domains already exists and isn’t close to expiry, acme.sh will skip obtaining a new one (avoiding unnecessary API calls or hitting Let’s Encrypt rate limits). You can force renewal or reissue if required (using a variable toggle, see **Role Variables**).
* **Post-deployment Hook:** You can specify a custom **service reload command** (e.g., to reload Nginx or Apache) to run after a certificate is obtained or renewed. The role will pass this command to acme.sh and also trigger an Ansible **handler** notification, ensuring that your web or proxy service can be reloaded to pick up the new certificate immediately.
* **Minimal Dependencies:** The role uses standard tools and a single script. It installs **git**, **curl**, and **cron** on the target (if not already present) to fetch and run acme.sh. No heavy Python modules or external Ansible collections are required – the logic relies on shell commands provided by acme.sh and GoDaddy’s API integration. This makes the role lightweight and easy to use on minimal server installs.

By using this role, you can seamlessly integrate Let’s Encrypt certificate provisioning into your server configuration process. For example, you might run this role on each web server or load balancer that needs a certificate for a domain managed in GoDaddy. Once complete, your server will have the certificate and private key stored (by default under **`/etc/letsencrypt/live/<primary_domain>`**), ready to be used in your web server or application configuration. This role is typically applied to the actual target host that requires the certificate (as it installs files and cron jobs on that host). After obtaining the cert, you should update your web service’s configuration to use the provided **cert.pem**, **privkey.pem**, and **fullchain.pem** files for SSL – or delegate that configuration to another role if applicable.

```mermaid
flowchart TD
    subgraph "Let's Encrypt (GoDaddy) Role Execution"
    Install[Install acme.sh & prerequisites<br/>(git, curl, cron)] --> Obtain[Obtain/Renew Certificate<br/>(DNS-01 challenge via GoDaddy)]
    Obtain --> Deploy[Deploy certificate files<br/>to target path & run reload cmd]
    Deploy --> Schedule[Schedule auto-renewal<br/>(cron job)]
    end
    Obtain -->|DNS API| GDAPI[(GoDaddy DNS<br/>API: create TXT record)]
    Obtain -->|ACME protocol| LetsEncryptCA[(Let's Encrypt CA<br/>(ACME server))]
    Deploy -->|optional| ReloadCmd["Service Reload<br/>command executed"]
    Schedule -->|daily| Cron[(Cron Daemon<br/>(auto-renew))]
```

## Supported Operating Systems/Platforms

**Target Systems:** This role is designed for **Debian-based Linux distributions**. It uses the `apt` package manager to install dependencies, so it has been tested on Debian and Ubuntu systems. Specifically, the role supports:

* **Debian** – Debian 10 (Buster), Debian 11 (Bullseye) and later releases (all versions are supported in general under the Debian family).
* **Ubuntu** – Ubuntu 20.04 LTS, Ubuntu 22.04 LTS (and likely other Ubuntu releases that use `apt` and systemd cron). The role should work on most modern Ubuntu versions.

Other Linux distributions *may* be used if they have similar package names and an `apt` command available (or if you modify the role to use an equivalent package module for that OS). However, out-of-the-box the role does **not support RPM-based systems** like RHEL/CentOS/AlmaLinux, as it lacks Yum/DNF tasks for installing packages. You would need to add those adaptations to use this role on such systems.

**Control Node:** The machine from which you run Ansible (the control node) can be any operating system that supports Ansible 2.14+ (Unix/Linux, or WSL on Windows, etc.). The role itself runs on the target hosts (with `become: true` to perform installations and file operations as root). There are no special control node requirements aside from having internet connectivity to reach external APIs during the play.

**Ansible Version:** This role requires **Ansible 2.14 or higher**. It utilizes fully qualified module names (e.g. `ansible.builtin.*`) and features that are available in modern Ansible distributions. Make sure your Ansible is up to date to avoid any deprecation or compatibility issues.

**Network Access:** The target host must have outbound internet access to Let’s Encrypt and GoDaddy endpoints. In particular, it needs to reach:

* **Let’s Encrypt ACME API** (default: `acme-v02.api.letsencrypt.org` on port 443) for certificate issuance and renewal.
* **GoDaddy API** (`api.godaddy.com` on port 443) for creating and removing DNS challenge records.
  If your environment has an egress firewall or proxy, ensure these connections are allowed; otherwise, the ACME challenge validation will fail. (Note: The DNS validation process means you do *not* need incoming HTTP access to port 80 on the host for validation as you would with an HTTP-01 challenge, which is an advantage in locked-down networks.)

## Role Variables

Below is a list of variables used by the **letsencrypt_godaddy** role, along with their default values (where applicable) and descriptions. Most of these are defined in the role’s **`defaults/main.yml`** and can be overridden in your playbook or inventory. Sensitive values (like API keys) should be provided via Ansible Vault or environment variables for security. **All variables are optional unless noted as “required”**, but you will typically need to set at least the required ones for the role to perform its function.

<!-- markdownlint-disable MD033 -->

<details><summary>Role Variables (defaults)</summary>

| Variable                        | Default Value                                  | Description |
| ------------------------------- | ---------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **`cert_domains`**              | *Empty list* `[]`                              | **(Required)** List of **domain names** for which to obtain the certificate. The first item in the list is considered the **primary domain** (certificate Common Name) and is used to name the certificate directory. Additional domains will be included as Subject Alternative Names. *No certificate will be issued if this list is empty* – the role will fail unless you provide at least one domain. Example: `cert_domains: ["example.com", "www.example.com"]`. Wildcard entries (e.g. "*.example.com") are supported (ensure you also include the base domain for a wildcard certificate for completeness). |
| **`letsencrypt_account_email`** | `""` (empty string)                            | Email address for the Let’s Encrypt account. This is **optional but recommended**. If provided, it will be used to create or update your ACME account and to receive expiration notices from Let’s Encrypt. If left blank, no email is associated with the account (acme.sh will still work without an email, but you might miss important notifications). Example: `"admin@example.com"`. |
| **`godaddy_api_key`**           | `""` (empty string)                            | **(Required)** The **GoDaddy API Key** with permissions to edit DNS records for your domain. This, together with the secret, is used by acme.sh’s `dns_gd` plugin to create and remove the DNS TXT challenge record. You must obtain this from your GoDaddy account (under developer settings). Treat this as a secret; do not expose it in plain text in source control (use Vault or environment variables). |
| **`godaddy_api_secret`**        | `""` (empty string)                            | **(Required)** The **GoDaddy API Secret** corresponding to the API Key above. This is essentially the “password” for the API Key. Like `godaddy_api_key`, this is required for the DNS challenge automation. Keep it safe – anyone with this and the key can modify your DNS records. |
| **`cert_install_path`**         | `"/etc/letsencrypt/live"`                      | The base directory where the certificate files will be placed (and organized by primary domain). By default, this imitates Certbot’s structure under **`/etc/letsencrypt/live/<domain>/`**, containing the `cert.pem`, `privkey.pem`, and `fullchain.pem` for your domain. If you prefer a different location for storing certs/keys (or need to avoid conflict with existing Certbot data), you can change this path. The role will create a subdirectory for the primary domain under this path if it doesn’t exist. |
| **`service_reload_command`**    | `""` (empty string)                            | Command to **reload or restart a service** after obtaining or renewing the certificate. By default this is empty (no service is automatically reloaded). If you set this to a valid command (e.g. `"systemctl reload nginx"` or `"apachectl graceful"`), the role will pass it to acme.sh as a reload hook **and** trigger an Ansible handler named **`reload_service`**. This means acme.sh will run the command upon successful renewal, and Ansible will mark the role execution as needing a service reload. **Note:** You should define a handler for `reload_service` in your playbook if you want Ansible to take an action (in many cases, acme.sh running the command is sufficient). Use this variable to ensure your web server or load balancer seamlessly picks up the new certificate. |
| **`use_staging`**               | `false`                                        | Whether to use Let’s Encrypt’s **staging environment** (ACME test server). When `true`, acme.sh appends the `--staging` flag, obtaining certificates from the staging CA (which are not publicly trusted). Use this for testing to avoid hitting rate limits on the production Let’s Encrypt API. The default is `false` (use the live production environment for real certificates). It’s recommended to set `use_staging: true` during initial trials or in CI tests, then switch to `false` for actual deployment. |
| **`propagation_wait`**          | `600`                                          | **DNS propagation wait time** in seconds. After creating the DNS TXT record for the challenge, acme.sh will wait this many seconds before asking Let’s Encrypt to verify it. The default is 600 seconds (10 minutes) to account for DNS caches and propagation delays. You can adjust this based on your DNS TTL and typical propagation speed: for many providers a shorter wait (60-120 seconds) may suffice, but GoDaddy’s DNS might require a longer delay in some cases. If validation fails due to DNS not being updated in time, increase this value. |
| **`acme_sh_install_dir`**       | `"/etc/acme"`                                  | Filesystem path where **acme.sh** will be installed and store its configuration. The role clones the acme.sh Git repository into this directory. It also uses this as the `--home` for acme.sh operations, meaning all acme.sh scripts, config, and default certificate storage will reside here (by default acme.sh would use `~/.acme.sh`, but we centralize it to `/etc/acme`). You can change this if you need the script to live elsewhere (for example, a user’s home directory), but `/etc/acme` is a convenient system-wide location. |
| **`acme_sh_git_url`**           | `"https://github.com/acmesh-official/acme.sh"` | The Git repository URL for the acme.sh client. By default, it points to the official **acmesh-official** GitHub repository. The role will clone from this URL. If you need to use a fork or a specific mirror (for instance, if your servers cannot access GitHub directly and you have an internal mirror), you can override this with your URL. Typically, you won’t need to change this. |
| **`acme_install_cron`**         | `true`                                         | Whether to **install the cron job** for automatic certificate renewal. If `true` (default), acme.sh will schedule a daily cron task (usually in `/etc/cron.d/`) to check and renew certificates automatically. This is highly recommended to keep your certificates valid. If set to `false`, acme.sh will skip installing the cron job (`--nocron` option) – use this only if you plan to handle renewal yourself (e.g. by running this role periodically via Ansible Tower/Automation or other scheduling system). |
| **`force_renew`**               | `false`                                        | Force renewal of the certificate even if it’s not near expiration. When `true`, the role adds the `--force` flag on the acme.sh issuance command, which tells acme.sh to obtain a new certificate regardless of the existing one’s status. By default this is `false` (no forced renewals), which means acme.sh will normally skip requesting a cert if one is already valid. Use `true` if you need to reissue the cert (for example, if you’ve added/removed domains, or if you suspect the current cert/private key is compromised or want to rotate keys). Be cautious with this to avoid hitting rate limits. |
| **`acme_sh_auto_upgrade`**      | `false`                                        | Controls acme.sh’s self-upgrade behavior. If `true`, acme.sh will be installed with the `--auto-upgrade` option, meaning it will periodically auto-update itself to the latest version (via its own cron job). If `false` (default), it installs with `--no-upgrade`, and acme.sh will **not** auto-update – it will remain at the version from the initial clone until you run the role again or update manually. The default is conservative (no auto upgrades) for stability and security. Enable this if you want acme.sh to keep itself up-to-date; however, be aware that auto-updates running as root could pose a risk if you don’t trust the upstream changes. |

</details>

## Tags

This role does **not define any custom Ansible tags** within its tasks. All tasks will run whenever the role is invoked, in the logical order (install, obtain, deploy).

You can still apply tags *externally* when including or running the role if you want to control when it runs as part of a larger playbook. For example, you might tag the entire role as `letsencrypt` in your play, and then run `--tags letsencrypt` to only execute this role’s tasks. Since the role’s tasks aren’t individually tagged, you cannot select subsets of them via tags (the tasks run as a unit). If more granular control is needed (say, to only run the renewal without reinstalling acme.sh), you would currently have to modify the role or use conditionals, as all tasks share the same tags context.

## Dependencies

**Ansible Collections:** None. This role uses Ansible built-in modules only (such as `apt`, `git`, `shell`, `file`, `cron`, etc.), all of which are part of the standard Ansible distribution. There is no need to install any additional Ansible Galaxy roles or collections to use `letsencrypt_godaddy`.

**System Packages on Target:** The role will ensure that a few prerequisite packages are present on the target system:

* **git** – used to clone the acme.sh repository.
* **curl** – used by acme.sh to communicate with the Let’s Encrypt API and GoDaddy API.
* **cron** (or cron service) – used to schedule the auto-renewal job (and required if `acme_install_cron: true`).

These packages are installed via `apt` on Debian/Ubuntu. You do not need to pre-install them; the role’s tasks handle that. However, ensure the target system’s package manager is functional and that you have an internet connection to fetch these packages.

Other standard utilities typically available on a Linux system are assumed present (such as **openssl**, which acme.sh uses under the hood for key generation and signing, and basic shell tools). On a normal Debian/Ubuntu server, you will have these by default. If using a very minimal base image, make sure that installing **openssl** (provided by libssl) and **socat** (sometimes used by acme.sh for certain challenge types, though not for DNS-GD) is possible. The default behavior of acme.sh with DNS challenges primarily uses curl and the DNS API, so additional tools are minimal.

**External Services:** This role depends on external services (Let’s Encrypt and GoDaddy). There are no offline alternatives provided. As such, a dependency is that those services are reachable and your API credentials for GoDaddy are valid. There is no hard dependency on any other Ansible role.

If you are running this role in an environment with restricted outbound internet, treat access to Let’s Encrypt and GoDaddy as prerequisites (for example, you might need to configure a proxy or use an allow-list for those endpoints).

In summary, aside from a standard Ansible environment and root access on the target, the main dependencies are:

* Ansible 2.14+ on the control node.
* A Debian/Ubuntu-like target with apt.
* Connectivity to required external APIs.
* Valid GoDaddy API credentials for your domain.

## Example Playbook

Here is a concise example of how to use the `letsencrypt_godaddy` role in a playbook to obtain a certificate for a domain. This example assumes you have a domain (e.g., **example.com**) managed in GoDaddy and you want to secure it (and optionally a `www` subdomain) with Let’s Encrypt. We’ll also assume you’ve stored your GoDaddy API credentials in environment variables for security (so we can fetch them without exposing secrets in the playbook):

```yaml
- name: Obtain Let's Encrypt certificate for Example.com
  hosts: webservers
  become: true
  vars:
    cert_domains:
      - "example.com"         # Primary domain for the certificate
      - "www.example.com"     # Additional domain (SAN) on the certificate
    letsencrypt_account_email: "admin@example.com"
    godaddy_api_key: "{{ lookup('env', 'GODADDY_API_KEY') }}"
    godaddy_api_secret: "{{ lookup('env', 'GODADDY_API_SECRET') }}"
    service_reload_command: "systemctl reload nginx"  # Reload Nginx to apply new cert
    use_staging: false        # Set true for testing, false for real certificate
  roles:
    - letsencrypt_godaddy
```

In the above playbook:

* We target a host group `webservers` (these are the machines that need the certificate). The play uses `become: true` because installing packages and writing to `/etc` require root privileges on the target.
* **Variables provided:** We define `cert_domains` with **example.com** and **www.example.com**. The role will request one certificate covering both names. We also set an email for the Let’s Encrypt account (so that Let’s Encrypt can send expiry notices). The GoDaddy API key and secret are fetched using the `lookup('env', ...)` function – this means you should export `GODADDY_API_KEY` and `GODADDY_API_SECRET` in your environment (or set them via an external vault/vars file) before running the play. This keeps secrets out of the playbook text. We specify a `service_reload_command` for Nginx, assuming Nginx is serving this domain on the host. With this set, after the cert is obtained, acme.sh will reload Nginx so it can immediately start using the new cert. We keep `use_staging: false` here because we want a real certificate – if you were testing, you might set it to true to use the staging environment.
* **Role invocation:** Including `- letsencrypt_godaddy` runs all tasks of this role on the hosts. When the play runs, the role will:

  1. Install git, curl, cron (if not already present).
  2. Clone the acme.sh script into `/etc/acme`.
  3. Run acme.sh to issue a certificate for *example.com* (with a SAN for *www.example.com*) using the GoDaddy DNS challenge. It will use the provided API credentials to create a `_acme-challenge.example.com` DNS record automatically.
  4. Wait for DNS propagation, then Let’s Encrypt will verify and acme.sh obtains the cert.
  5. The role then installs the certificate files to `/etc/letsencrypt/live/example.com/` (creating that directory if needed). It will place `cert.pem`, `privkey.pem`, etc. in that folder.
  6. Because we set a reload command, acme.sh will execute `systemctl reload nginx` after placing the new cert. The role also emits a notify for `reload_service`, which would allow an Ansible handler to run if defined (in this case it’s redundant since acme.sh already reloaded Nginx).
  7. It will schedule the cron job for renewal (by default, daily checks).
* **After the playbook run:** The server(s) in `webservers` now have a live Let’s Encrypt certificate for your domain. You should ensure your Nginx (or Apache, etc.) is configured to use the certificate files from `/etc/letsencrypt/live/example.com/`. If you used the reload command and your Nginx config was already referencing those paths, the reload would make Nginx pick up the cert immediately. If not, you may need to adjust your webserver configuration accordingly.

You can also split this configuration into inventory or group variables. For example, you might put the domain list and credentials into `group_vars/webservers.yml` to avoid repetition or exposing them in the playbook. The role is flexible – as long as the required variables are defined by the time the role runs, it will work.

## Testing Instructions

It is recommended to test this role using **Molecule** (with Docker) to verify its behavior before using it on critical systems. This role includes a Molecule test scenario (in the `roles/letsencrypt_godaddy/molecule/` directory) that can spin up a temporary container and run the role. Because the role interacts with external services (Let’s Encrypt’s CA and GoDaddy’s DNS), a few considerations apply when testing:

1. **Set up Molecule and Docker:** Ensure you have Molecule installed (e.g., `pip install molecule[docker]`) and Docker running on your machine. The Molecule default scenario uses Docker containers to simulate a target host (often a Debian base image).
2. **Review/Configure the test scenario:** The default Molecule scenario for this role is configured to use dummy values and the Let’s Encrypt staging environment. Open the file `molecule/default/converge.yml` – you’ll see that it provides sample variables:

   * `cert_domains: ["example.com"]`
   * `godaddy_api_key: "dummy"`
   * `godaddy_api_secret: "dummy"`
   * `use_staging: true`
   * `service_reload_command: "/bin/true"` (a no-op command for testing)

   These dummy credentials will not actually succeed in obtaining a certificate, but they allow the role to execute up to the point of attempting the ACME challenge. Using staging (`use_staging: true`) ensures we’re not hitting production rate limits. If you want the test to actually complete a certificate issuance, you would need to replace the dummy key/secret with real GoDaddy API credentials and use a domain that you own for testing. Keep in mind you should still use staging mode for tests to avoid quota issues and to prevent getting untrusted certificates.
3. **Run Molecule tests:** From the role directory (`roles/letsencrypt_godaddy`), run the following commands:

   * `molecule create` – this will create the Docker container(s) defined in the scenario.
   * `molecule converge` – this runs the role inside the container as per the playbook in the scenario (applying `converge.yml`). Watch the output to see each task execute. If using the default dummy settings, the **“Issue or renew certificate”** task will likely fail to actually get a certificate (since the API credentials won’t authenticate). However, the goal in a test could be to ensure the tasks run and the failure is handled as expected. If you provided real credentials and a valid domain, you may see the full success output (look for “Cert success” messages in stdout, though note the task is marked no_log so you might not see all details).
   * `molecule verify` – if there are any verification steps or tests (this role’s scenario might not have additional tests beyond just running the role, as it’s tricky to verify an external outcome without real credentials).
   * `molecule destroy` – to tear down the test container and cleanup.

   You can also run `molecule test` to do the create -> converge -> verify -> destroy sequence in one go.
4. **Interpreting test results:** If using dummy data, the converge step will reach the certificate issuance task and likely encounter an error from acme.sh (because of authentication failure to GoDaddy or Let’s Encrypt verification failure for example.com). In a dry-run test, this is acceptable to see how the role behaves. You should at least confirm that all prior steps (package install, cloning acme.sh, etc.) complete without errors, and that the failure is indeed due to the external call (which it will be in this scenario). For a more complete test, use valid data:

   * Set environment variables or edit `molecule/default/converge.yml` to include a real domain you control and the correct `godaddy_api_key` and `godaddy_api_secret` for that domain.
   * Perhaps use a subdomain that you don’t mind issuing a test certificate for. Keep `use_staging: true` to avoid any impact on production certificates.
   * Run `molecule converge` and it should complete all tasks successfully, obtaining a staging certificate. You can shell into the container (e.g., `docker exec -it <container-id> /bin/bash`) to inspect `/etc/letsencrypt/live/<domain>` and verify the certificate files exist.
5. **Cleanup:** After testing, ensure you run `molecule destroy` to remove the test container. Also revoke any test certificates if you used real domains and want to keep things tidy (staging certs don’t count against rate limits, but production ones do if you accidentally obtained any).

Running Molecule tests for this role is a good way to catch issues in a controlled environment. Because the role touches external APIs, failures can occur due to network issues or misconfigured credentials – testing helps ensure your variables and environment are correct before you run it on real servers. It’s also useful for regression testing if you modify the role.

## Known Issues and Gotchas

While the **letsencrypt_godaddy** role aims to simplify certificate management, there are a few things to be aware of to avoid common pitfalls:

* **Provide All Required Variables:** The role will fail early if `cert_domains` is empty. Make sure you specify at least one domain. Similarly, if `godaddy_api_key` or `godaddy_api_secret` are not provided (empty), the ACME challenge will fail (acme.sh will be unable to authenticate to GoDaddy’s API). Always double-check that these variables are set (especially if using environment lookups or vault files). If the playbook stops at the "Fail if domains are not set" task or if you see an error about GoDaddy authentication, it usually points to missing or incorrect variables.
* **DNS Ownership:** This role assumes that the DNS zone for the domain(s) in `cert_domains` is managed in the GoDaddy account corresponding to the provided API credentials. If, for example, your domain’s DNS is actually hosted elsewhere (or you typo’d the domain), the DNS challenge will not propagate and Let’s Encrypt validation will fail. Ensure you use the correct domain name and credentials. If you have subdomains delegated to other DNS providers, the challenge might need to be done on those providers instead of GoDaddy.
* **Execution Time (DNS Propagation):** The DNS-01 challenge process can be slow due to propagation. The default `propagation_wait: 600` means the play will sleep for 10 minutes during the certificate request. This is intentional to ensure validation succeeds on the first try. If your DNS updates much faster, you can lower this to speed up runs, but be cautious: too short a wait can cause validation to fail (and you’ll have to rerun, potentially hitting rate limits if done repeatedly). On the other hand, if you consistently hit validation issues, consider increasing the wait time. This long wait can make the playbook run time noticeable (don’t assume it’s hung – it may just be waiting the full duration).
* **Idempotency and Re-runs:** On subsequent runs, if a valid cert exists, acme.sh may output that the certificate is up-to-date and skip obtaining a new one. In such cases, the role’s “Issue or renew certificate” task might report **Ok** (no change) and no new certificate is retrieved – this is expected behavior. The role checks for `"Cert success"` in output to mark a change. If nothing was done, you’ll see the role complete with no changes in that step. If you need to force a certificate refresh (e.g., you added a new domain to `cert_domains` or want to rotate keys), set `force_renew: true` for that run. This will force acme.sh to attempt obtaining a fresh cert even if one is present.
* **Certificate Revocation or Removal:** The role does **not** handle revocation or deletion of certificates. If you remove a domain from `cert_domains` and re-run the role, acme.sh will not automatically revoke the old certificate that included that domain. It may either treat it as no change (if primary domain is the same and it doesn’t realize a SAN was removed), or issue a new certificate without the removed name (if forced) but leave the old certificate files on disk. You may need to manually clean up unwanted certificates (using acme.sh commands or by removing files) and possibly revoke them via Let’s Encrypt if they should no longer be trusted. Similarly, if you want to uninstall acme.sh or remove the cron job, those actions aren’t performed by this role’s default tasks (you would handle those manually or via an uninstall play).
* **No Logging of Sensitive Output:** The tasks that execute acme.sh are run with `no_log: true`. This means Ansible will suppress the output of those tasks in the playbook logs to avoid leaking secrets (since the commands include your API credentials). The downside is that if something fails during certificate issuance, you won’t see the exact error message in the Ansible output – you’ll just get a generic failure. To troubleshoot, you may need to rerun the play with `-vvv` for more verbose logging (which might still hide the command output due to `no_log`, but could show some context), or manually run the equivalent acme.sh command on the host for debugging. A common issue might be a DNS validation error or an API error; checking the system’s `/var/log` or running acme.sh by hand (as root) can help pinpoint the problem. Remove or comment out `no_log` in the role *temporarily* if you need to see the full output for debugging (just be cautious not to expose it widely).
* **Multiple Servers & Challenges:** If you have multiple servers needing the *same* certificate (for example, in a load-balanced setup where each server should have the cert), you have a couple of options:

  1. Run this role on one designated host to obtain the certificate, then distribute the certificate files to the other servers (outside the scope of this role). This avoids hitting Let’s Encrypt with duplicate requests. You’ll need to sync `/etc/letsencrypt/live/<domain>` contents securely to the other hosts and reload their services.
  2. Or run the role on each server (each will attempt to get its own cert). This is easier but note that if they run simultaneously, they might conflict with each other via the DNS challenge (each one adding/removing the `_acme-challenge` record). Stagger the runs or use the first approach to be safe. Let’s Encrypt also has duplicate certificate rate limits, so obtaining the same cert on multiple machines at the same time could hit those limits.
* **Cron Job Behavior:** When `acme_install_cron: true`, acme.sh installs a cron job (usually running daily around midnight or a random time) to auto-renew certificates. This means renewal is largely autonomous and does not require Ansible. The cron executes the `acme.sh --cron` command as root. It will only actually renew certs when they are within 30 days of expiry (acme.sh’s default). Be aware of this if you prefer using Ansible for renewals – you might end up with two processes trying to manage certs if you, say, run this role via a scheduler as well. If you decide to handle renewals via Ansible runs (for example, using AWX/Tower or a Jenkins job), you might disable the cron (`acme_install_cron: false`) and periodically run the role with `force_renew: false` (so it only renews when needed). Most users, however, will find leaving the cron enabled convenient. Also note: The cron job and acme.sh script will produce output to a log file (in `/var/log/letsencrypt/` or `~/.acme.sh/` logs) or email depending on your system cron setup. Monitor those if you suspect renewals aren’t happening.
* **File Permissions and Access:** The role creates the certificate directory with `0755` permissions (readable by all users, but only writable by root) and the certificate files themselves will be created by acme.sh (usually the private key `privkey.pem` will be `0600` or `0400` for security, and public cert `cert.pem` and `fullchain.pem` might be `0644`). This setup means the private key is only readable by root (or processes running as root). In most cases, that’s what you want for security. Your web server (Nginx, Apache) typically runs as root on start and can read the key, then drops privileges. However, if you have a service running as a non-root user that needs direct access to the key file, you may need to adjust permissions or copy the files to a location with appropriate ownership. Be very careful with this – never make your private keys world-readable. It’s best to let root-owned processes handle them. If you do need to share the key with a specific service user, consider creating a user group, placing the user in that group, and adjusting file group ownership and permissions accordingly (outside the role, as a post-task or in the service role).
* **ACME Client Choice:** This role specifically uses **acme.sh** as the ACME client. If you have been using Certbot (the official Let’s Encrypt client) elsewhere, note that acme.sh stores certificates in its own location (`acme_sh_install_dir`, default `/etc/acme`) and then copies to the `cert_install_path`. It does not interface with Certbot’s data or hooks. This means if you run Certbot on the same machine, you’ll have two separate systems unaware of each other. It’s generally recommended to stick to one method per server to avoid confusion or conflicts. If migrating from Certbot to acme.sh (via this role), you might want to revoke or delete old Certbot certificates and disable its timers/cron, to let acme.sh take over the renewal process completely.
* **Rate Limits:** Let’s Encrypt enforces rate limits (e.g., currently 5 duplicate certificates per week for the same set of domains, among other limits). During testing or if something misbehaves (like repeatedly failing challenges), you could hit these limits. Using `use_staging: true` prevents that in test scenarios. In production, if you ever need to reissue frequently (perhaps you’re tweaking domain names or experimenting), be mindful of these limits. If a limit is hit, acme.sh will report an error and you’ll have to wait or use staging. Rate limit info can be found on Let’s Encrypt’s documentation. The role itself doesn’t prevent you from hitting limits if used incautiously, so it’s up to the user to manage frequency of certificate requests appropriately.

In summary, ensure you provide correct inputs and understand that while the role automates a lot of steps, external factors like DNS and Let’s Encrypt’s policies can affect the outcome. Most issues boil down to DNS not updating in time, missing/incorrect variables, or environment connectivity problems. With proper setup, the role should run smoothly and provide you with valid certificates.

## Security Implications

Using this role involves handling sensitive operations and data. Below are important security considerations and how the role addresses them:

* **Exposure of API Credentials:** The GoDaddy API key and secret are powerful credentials – they allow modifications to your DNS records (and potentially other account actions). It’s crucial to keep them confidential. This role does not write the API key/secret to disk at any time; it only exports them as environment variables for the duration of the acme.sh command. We have `no_log: true` on the tasks to avoid leaking them in Ansible output. Still, you as the user should ensure these credentials are stored securely in your Ansible workflow (e.g., use Ansible Vault, environment variables on the control node, or a secrets manager). Avoid placing them in plain text in version control. If someone unauthorized obtains these, they could hijack your domain’s DNS, which is a severe security risk (they could validate their own certificates or redirect traffic).
* **Privileges and acme.sh:** The role runs with **root privileges** on the target host (because installing packages, writing to `/etc`, and cron jobs require it). The acme.sh script itself is executed as root. This means you are trusting the acme.sh code with root access on your server. acme.sh is a widely used ACME client, but it is an external script downloaded from the internet (the GitHub repo). We default to the official repository to mitigate tampering, but it’s still code running as root. We disable auto-upgrade by default (`acme_sh_auto_upgrade: false`) to ensure acme.sh doesn’t change unexpectedly after installation – you control when it updates (by running the role again or manually updating). If you enable auto-upgrade, be aware that you’re allowing a script to fetch and run new code as root on a schedule. From a security standpoint, that’s a trade-off between convenience and control. Many users trust acme.sh’s maintainers and run auto-updates; others prefer to pin a version. You can decide based on your risk tolerance.
* **Cron Job (Privilege & Security):** The cron job that acme.sh installs (if enabled) will run as root (usually in `/etc/cron.d/acme.sh` or the user’s cron depending on installation method, but in our case using `--home /etc/acme` likely puts a script in `/etc/crontab` or `/etc/cron.d`). This job will periodically invoke acme.sh to renew certificates. As it runs as root, any potential exploit in the ACME client or a malicious update could run commands as root. Again, disabling auto-upgrade mitigates the risk of unknown code running, but the cron will still run the existing acme.sh codebase. Ensure your servers’ security posture is strong: keep system packages updated, and perhaps restrict outbound connectivity if possible (acme.sh generally contacts Let’s Encrypt and your DNS API – consider if you need to firewall egress beyond those). Also, the cron job’s command is typically something like `/etc/acme/acme.sh --cron --home /etc/acme`, which shouldn’t expose secrets directly (the credentials are stored in acme.sh config as `GD_Key` and `GD_Secret` environment variables in a config file or exported each run). The role’s approach with environment variables means your credentials might also be stored in acme.sh’s config file (`/etc/acme/account.conf` or similar). That file is root-only readable. Still, treat the machine as sensitive because it holds keys to both your certificates and DNS.
* **Created Files (Certificates and Keys):** The primary security benefit of this role is obtaining a trusted certificate, but that comes with the responsibility of safeguarding the **private key**. The private key (`privkey.pem`) for your certificate is saved on the target host’s disk (under `/etc/letsencrypt/live/<domain>/` by default). The role ensures directory permissions are such that only root can write, and acme.sh by default will set file permissions so that private keys are not world-readable. Verify that `privkey.pem` is `600` (rw-------) or similarly restricted. An attacker with access to that key can impersonate your site, so system security is critical. Make sure only authorized users can access that host. Using the Base role or other hardening (firewalls, intrusion detection) in conjunction is wise. If you back up these files, treat those backups securely as well.
* **Ports and Services:** This role itself does not open any network ports or start any long-running services. It doesn’t modify firewall rules. The certificate it obtains is typically used by services like web servers on port 443. You should ensure port 443 (HTTPS) is allowed through your firewall (for example, if you use the **base** role with UFW, enable HTTPS). While obtaining the certificate via DNS-01 doesn’t require port 80, your actual service might (for HTTP->HTTPS redirects) – that’s outside this role’s scope but important for overall deployment. Also, the role does not directly restart any service unless you provided a `service_reload_command`. If you did, that command will be executed (by acme.sh) and presumably will reload a service (like Nginx). Be certain that reload command is correct and safe to run – it should ideally be a non-disruptive reload. Using reload vs restart is recommended to avoid downtime, but ensure the command indeed only reloads configuration.
* **Let’s Encrypt Account and Terms:** When using this role, you implicitly create a Let’s Encrypt account (through acme.sh) if one doesn’t exist, and you agree to Let’s Encrypt’s Subscriber Agreement. The email (if provided) is used for communications from Let’s Encrypt. Keep this in mind especially when using staging vs production – staging uses a separate account. No real security issue here, just an operational note: ensure you’re aware of which account key is being used. The account key will be saved in the acme.sh config directory. Protect it similar to a private key (acme.sh usually keeps account keys in `account.conf` or `/<home>/*account.key` with proper permissions).
* **Interaction with Other Security Measures:** If you have intrusion detection or security monitoring on the host, be aware that this role will execute a series of actions that might flag those systems:

  * Installing packages (APT operations).
  * Cloning from GitHub (outbound connection to github.com).
  * Making HTTPS calls to Let’s Encrypt and GoDaddy.
  * Writing to /etc/letsencrypt and /etc/acme.
  * Adding a cron job.

  Ensure these are accounted for in your change management or monitoring. For example, some security setups might alert on new cron jobs or root executing unfamiliar scripts.
* **Post-Certificate Usage:** Having a certificate on the server is just one piece of the puzzle. You need to configure your applications to use it. Make sure to remove or disable any self-signed certificates you might have used temporarily. Also, prefer using the full chain provided (`fullchain.pem`) in your server configs to ensure clients have the complete certificate chain. The role doesn’t handle any application config (since it doesn’t know what server you’re using), so linking the certificate into your app config (and reloading the app) should be done with care – that’s where the provided reload hook helps.
* **Cleaning Up Secrets:** If for some reason you need to remove this role’s artifacts (say you mistakenly exposed the API secret and want to rotate credentials), you should:

  * Get new API keys on GoDaddy (invalidate the old ones).
  * Remove or update the stored credentials in acme.sh config (acme.sh might cache the API credentials in its config under `/etc/acme` – check `~/.acme.sh/account.conf` or similar for lines like `GD_Key` and `GD_Secret`; those would contain your key and secret in plaintext. They are only readable by root, but if rotating credentials, update or remove those).
  * Revoke certificates if needed (acme.sh has commands for revocation) if a key compromise is suspected.
  * Remove the cron job if you no longer want auto-renewal or are decommissioning the service (delete the cron file in /etc/cron.d or comment out the entry, and possibly remove the acme.sh installation directory if you’re done with it entirely).

  These are manual steps – the role doesn’t provide a “teardown” playbook, but you can write a simple play to remove `/etc/acme`, `/etc/letsencrypt/live/domain`, and the cron job if needed.

In essence, this role is intended to improve your security by enabling HTTPS, but it must be used responsibly. Keep secrets safe, maintain your systems, and you’ll get the benefit of automated, regularly renewed encryption with minimal risk. Always consider the overall security posture of the system: SSL certificates protect data in transit, but the private keys and DNS credentials must be protected at rest.

## Cross-Referencing

This repository contains other roles and components that can be relevant to or used in combination with **letsencrypt_godaddy** depending on your needs:

* **[letsencrypt_setup](../letsencrypt_setup/README.md)** – *Alternative Let’s Encrypt role (Certbot-based).* In addition to the acme.sh-based approach of `letsencrypt_godaddy`, the repository includes a `letsencrypt_setup` role which uses the Certbot client. That role can obtain certificates using either the **GoDaddy DNS plugin** for Certbot or the webroot method. If your environment or preference leans towards Certbot (for instance, if you want to use other DNS providers or the HTTP challenge), you might explore `letsencrypt_setup`. It’s useful for scenarios where you have a web server accessible on port 80 (for HTTP-01 validation) or if you want to integrate with different DNS services by installing the appropriate Certbot DNS plugins. Keep in mind that using Certbot involves Python dependencies and runs a different automation path (it will install packages like `certbot` and possibly a PPA on Ubuntu for the latest version). Choose the role that best fits your environment – both achieve similar end goals (getting Let’s Encrypt certs) but via different tools.
* **[cloudflare](../cloudflare/README.md)** – *Cloudflare DNS & CDN Management Role.* If your DNS is hosted on **Cloudflare** instead of GoDaddy, the `letsencrypt_godaddy` role won’t directly help for certificate issuance (since it’s specifically tied to GoDaddy’s API). However, you have options to do DNS-based validation with Cloudflare as well. While this repository doesn’t have a dedicated “letsencrypt_cloudflare” role, one approach is to use the `letsencrypt_setup` role mentioned above with the Cloudflare DNS plugin for Certbot (i.e., installing `python3-certbot-dns-cloudflare`). Alternatively, acme.sh (used in this role) also supports Cloudflare’s API if configured properly, though that would require a slight adaptation of this role or a separate role. The **Cloudflare** role in this repo is more about managing Cloudflare settings (DNS records, security policies) as part of your infrastructure-as-code. You might use that role to ensure your DNS records are in place for your services, and then use a Let’s Encrypt method that works with Cloudflare (for instance, some people use Cloudflare’s proxy and HTTP validation, or DNS validation with a Cloudflare token). In summary, if you host domains on Cloudflare, see the Cloudflare role for managing DNS and consider using a Cloudflare-compatible ACME client (Certbot+Cloudflare plugin, or acme.sh with Cloudflare) for certificates.
* **[bind9](../bind9/README.md)** – *Internal DNS Server Role.* Some environments run their own DNS (via BIND9) for internal name resolution. If you use BIND9 internally and GoDaddy for external DNS, be mindful of where the ACME challenge needs to happen: Let’s Encrypt will always look at the authoritative public DNS (GoDaddy in this case) for the `_acme-challenge` record. The **BIND9** role would typically be for internal DNS zones (which are irrelevant to Let’s Encrypt’s validation). However, using BIND9 internally and GoDaddy externally means you have split DNS – ensure consistency for hostnames if needed. For instance, you might use the BIND9 role to set up internal resolution for `example.com` while the external DNS is on GoDaddy. The certificate issuance will still require the external (GoDaddy) to have the TXT record. As long as this role is used, it will handle the external part. The two can coexist; just coordinate domain names and perhaps use the same hostnames internally/externally as appropriate.
* **[base](../base/README.md)** – *Base OS hardening role.* This role can be run on all servers to configure firewalls (UFW on Ubuntu/Debian), SSH settings, fail2ban, etc. It complements `letsencrypt_godaddy` because after obtaining a certificate, you’ll typically serve HTTPS on port 443. The Base role can ensure port **443** (and 80 if needed for redirects) is allowed through the firewall. Also, base sets up general security best practices that, together with TLS provided by your certs, enhance overall security. There’s no direct integration needed between base and letsencrypt roles – just ensure that if UFW is enabled by base, you open the necessary ports for web traffic. Additionally, base’s hardening (like disabling unused services or ensuring proper permissions) provides a secure foundation so that your private keys and services remain safe.
* **Application or Web Service Roles:** After obtaining a certificate, the next step is using it in your application (web server, API endpoint, etc.). This repository has numerous roles for deploying applications and services (for example, **[apache_airflow](../apache_airflow/README.md)**, **[apache_superset](../apache_superset/README.md)**, **[amundsen_frontend](../amundsen_frontend/README.md)**, **[keycloak](../keycloak/README.md)**, and others). Many of these applications can be served over HTTPS. Typically, you would integrate the certificate by configuring the web server or the application’s TLS settings. For instance, if you have an **NGINX** or **HAProxy** in front of these applications:

  * For **HAProxy**, you might use the **[haproxy](../haproxy/README.md)** role to set up a load balancer and provide it the path to the certificate. The haproxy role has a variable `haproxy_ssl_certificate` which should point to a combined certificate file (cert + key). You could, for example, combine `/etc/letsencrypt/live/<domain>/fullchain.pem` and `privkey.pem` into one file (this is a typical requirement for HAProxy) and reference that. You might automate that combination with a small task or script, or adjust the haproxy role if needed. The key is that after `letsencrypt_godaddy` runs, you have the material needed to enable TLS in HAProxy.
  * For **Nginx/Apache** (if you have a role setting those up, or if they are part of the application role), you’d ensure the config points to the certificate file and key file under `/etc/letsencrypt/live/<domain>/`. Often, no modification to this role is needed – you pre-configure the webserver role to expect those files and just run this role beforehand to make sure they exist. Then a reload signal (as provided by this role’s hook) can make the server pick up the cert.

  The workflow in a playbook might be: run `letsencrypt_godaddy` role, then run your web app role (or vice versa, depending on if the webserver needs to be present to handle anything – but since we’re using DNS validation, the webserver doesn’t need to be running to get the cert). Some prefer to obtain certs after the webserver is installed but before it’s serving traffic, others obtain first then configure webserver. Both approaches are viable as long as you coordinate the roles. The bottom line is that this role can be combined with your application roles to automate end-to-end deployment of secure services.
* **Cloudflare & Let’s Encrypt Integration:** While this role is GoDaddy-specific, it’s worth noting (as a broader point) that if in the future you move DNS providers or add others, the approach to Let’s Encrypt via DNS-01 will change. The Cloudflare role documentation (see Cross-Referencing in the Cloudflare README) discusses using DNS challenges with Cloudflare. In our context, if you ever needed to do something similar with Cloudflare, you could extend either this role or use the Certbot method. At present, if you primarily use GoDaddy, you’re covered by this role. Just remember that the concept of DNS challenges is transferable – the main difference is the API used. So, for completeness: **if you have domains not on GoDaddy, do not use this role for those** – use the appropriate method (the repository doesn’t have roles for all DNS providers, so you might use an official plugin or an external role).

Each of the roles mentioned has its own documentation and purpose. **letsencrypt_godaddy** is often just one piece of a larger puzzle: it provides the certificates that another role (web server, proxy, etc.) will use, or it works alongside roles that manage DNS or security. By combining roles, you can automate a full scenario. For example, a play might: run the base role to harden the server, run an application role to deploy your app, run letsencrypt_godaddy to fetch certificates, and run a web server role to configure TLS (or use reload commands to refresh an existing web server config). Understanding what each role does will help you order them correctly and ensure they complement each other rather than conflict.
