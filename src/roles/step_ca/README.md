# Ansible Role: Step CA

**Table of Contents**

* [Overview](#overview)
* [Supported Operating Systems/Platforms](#supported-operating-systemsplatforms)
* [Role Variables](#role-variables)
* [Tags](#tags)
* [Dependencies](#dependencies)
* [Example Playbook](#example-playbook)
* [Testing Instructions](#testing-instructions)
* [Known Issues and Gotchas](#known-issues-and-gotchas)
* [Security Implications](#security-implications)
* [Cross-Referencing](#cross-referencing)

## Overview

The **Step CA** role installs and configures [Smallstep *step-ca*](https://github.com/smallstep/certificates) – an open-source certificate authority server – on a target Linux host. This role takes care of setting up the Step CA service as a systemd daemon running under a non-root user, managing the necessary installation packages, configuration files, and service unit. By applying this role, you get a functioning private CA that can issue X.509 (TLS) certificates (and optionally SSH certificates) within your environment. Key tasks performed by this role include:

* **Package Repository & Installation:** Adds the official Smallstep APT repository and GPG key, then installs the **step-ca** server package and the accompanying **step** CLI tool via the system package manager. This ensures you have the specified (or latest) version of Step CA and CLI available on the host.
* **User and Directory Setup:** Creates a dedicated system user (default **`step`**) and group to run the CA service, with no login shell for security. It also prepares the directory structure (by default **`/home/step/.step`** with a **`config`** subdirectory) to hold the CA configuration and keys. File permissions are set strictly (config directory with mode 0750 and key files 0600) so that only the Step CA user (and root) can access sensitive materials.
* **Bootstrapping the CA (Optional):** If enabled via `step_ca_bootstrap: true`, the role will initialize a new CA on first run by executing `step ca init` in non-interactive mode. This generates a root CA certificate and key, an initial ACME provisioner, and a default configuration (**`ca.json`**) for a standalone CA. You must provide at least one DNS name for the CA’s certificate (`step_ca_dns_names`) and handle the CA password (see **Known Issues**). The bootstrap step is only run when needed (guarded so it doesn’t overwrite an existing CA if rerun).
* **Configuration:** Deploys the main Step CA configuration file from a Jinja2 template (`ca.json`) into the config directory. This JSON config includes network listen address, CA DNS names, and backend settings. If you are using an **external RA (Registration Authority) mode with Vault** or an external SQL database for Step CA, the template injects those settings (Vault address, AppRole credentials, MySQL connection string, etc.) accordingly. The role also templates a systemd service unit (`step-ca.service`) to `/etc/systemd/system/`, configured to start the Step CA process as the dedicated user, binding to the chosen address/port, and reading the password file for the CA key.
* **Service Management:** Enables and starts the **step-ca** service via systemd. After installation and configuration, the CA service is started immediately and enabled on boot. Handlers are provided to **reload systemd** (when the unit file changes) and **restart the Step CA service** whenever the config file or service unit is updated. This ensures that changes to configuration (like adding new DNS names or changing ports) will take effect by restarting the CA. The role is designed to be idempotent; re-running it will only make changes if configuration drifts (for example, if you change a variable, the template will update `ca.json` and trigger a restart).
* **Vault RA Mode (Optional):** Instead of operating a standalone root CA, this role can configure Step CA to act as an *intermediate CA* backed by **HashiCorp Vault**. By setting `step_ca_use_vault_ra: true`, you instruct the role to skip the local bootstrap and instead populate `ca.json` with the settings to connect to a Vault PKI secrets engine (acting as the upstream CA). In this mode, Step CA will obtain its signing certificate from Vault (using AppRole auth) and store issued certificate data in a SQL database (MySQL is supported). This enables a **High-Availability CA** setup: you can run multiple Step CA instances behind a load balancer, all leveraging the same Vault CA and shared DB. (The role does **not** automatically deploy multiple nodes or the Vault/DB servers; see **Cross-Referencing** for related roles.)

In summary, this role sets up a private CA service (Step CA) according to best practices: running under a least-privilege account, optionally initializing a fresh PKI or integrating with an external CA, and managing the service lifecycle. It does **not** handle higher-level PKI tasks such as creating additional provisioners, ACME configurations, or issuing end-entity certificates – those should be done using the **step** CLI or Step CA’s API after deployment. The role focuses on installation and initial configuration of the CA server itself.

## Supported Operating Systems/Platforms

This role is currently designed for **Debian-based Linux distributions**. It relies on APT for package management and uses Debian/Ubuntu conventions, so it has been tested and verified on:

* **Debian 11 (Bullseye)** and **Debian 12 (Bookworm)** – these are the primary supported platforms as declared in the role metadata. The tasks (APT repository setup, etc.) have been specifically checked on these releases.
* **Ubuntu LTS releases** (20.04 Focal, 22.04 Jammy, etc.) – *likely supported but not explicitly listed*. Ubuntu shares the Debian package format and systemd usage, and the Smallstep APT repository can work on Ubuntu. However, note that the repository’s distribution codename must match. For example, if using Ubuntu Jammy, the role will attempt to use `jammy` in the Smallstep repo URL – if Smallstep provides packages for Jammy or if Jammy is compatible with Bullseye’s packages, it should work. In practice, many have used Step CA on Ubuntu successfully by using this role or by manually adjusting the repo codename if needed.
* **Other Debian derivatives** (Kali, Raspbian, etc.) – might work if they use the APT packaging system and systemd. This role should function on those as long as the CPU architecture is amd64 (the Smallstep repo provides 64-bit binaries). On ARM-based Debian (e.g., Raspberry Pi OS 64-bit), you may need to adjust how you install Step CA (Smallstep’s repo may or may not have ARM packages). This role doesn’t handle alternate architectures out-of-the-box – you would have to manually download an ARM binary or skip the package tasks.

**Not supported out-of-the-box:** Red Hat Enterprise Linux, CentOS, AlmaLinux, Rocky, Amazon Linux, or any non-Debian OS. The role does not include YUM/DNF tasks or other package manager support, and it assumes the presence of systemd. Attempting to run it on RHEL/CentOS without modification will fail (no `apt` available, different service setup). Adapting it to those systems would require adding appropriate tasks for those package managers and possibly using Smallstep’s tarballs or a different installation method. In short, use Debian/Ubuntu hosts for this role unless you plan to extend it for other platforms.

## Role Variables

Below is a list of the role’s variables, along with their default values (defined in **`roles/step_ca/defaults/main.yml`**) and descriptions. These variables can be overridden in your playbook or inventory to customize the Step CA deployment.

<!-- markdownlint-disable MD033 -->

<details><summary>Role Variables (defaults/main.yml)</summary>

| Variable                      | Default Value                        | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| ----------------------------- | ------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **`step_ca_version`**         | `"latest"`                           | **Version of the Step CA server to install.** By default, this role installs the latest available version from Smallstep’s APT repository. If you want to pin a specific version, set this to that version string (e.g. `"0.25.1"`). The role will then install **step-ca=\<version>** via APT, ensuring that exact version is used (if available in the repo). When left as `"latest"`, the APT install will grab the newest version.                                                                                                                                                                                                                                                                                                          |
| **`step_ca_cli_version`**     | `"latest"`                           | **Version of the Step CLI tool to install.** The Step CLI (`step` binary) is often installed alongside the CA. By default this is `"latest"`, which ensures the latest CLI is installed. You can specify a version (e.g. `"0.25.1"`) to match the Step CA version if desired. The role uses this when installing the **`step`** package via APT. If set to `"latest"`, it will not pin a version (installing whatever is current in the repo).                                                                                                                                                                                                                                                                                                  |
| **`step_ca_user`**            | `"step"`                             | **System user account name for running the Step CA service.** The role will create this user if it does not exist. It is created as a system user (no password, no interactive login, shell set to `/usr/sbin/nologin`). All CA files (certificates, keys, config) will be owned by this user, and the systemd service runs as this user for security. You can change this username if needed (for example, to comply with naming policies), but ensure it’s dedicated to Step CA.                                                                                                                                                                                                                                                              |
| **`step_ca_group`**           | `"step"`                             | **System group name for Step CA files.** The role will create this group (if not existing) and typically it should match the `step_ca_user`. All files and directories created by the role will be owned by `step_ca_user:step_ca_group`. In most cases you can leave this as-is (changing it is rarely necessary unless integrating with a pre-existing account or group).                                                                                                                                                                                                                                                                                                                                                                     |
| **`step_ca_home`**            | `/home/step`                         | **Home directory for the Step CA user.** This is where Step CA will store its PKI materials. By default, it uses `/home/step` (since the user `step` is created with this home). Inside this, Step CA will create a hidden `.step` directory containing configuration, certificates, and keys. If you change the user, you might also change this path accordingly.                                                                                                                                                                                                                                                                                                                                                                             |
| **`step_ca_config_path`**     | `{{ step_ca_home }}/.step/config`    | **Directory for Step CA configuration files.** The role will ensure this directory exists (owned by the Step CA user). By default it is a `config` folder under the Step CA home’s `.step` directory (e.g. `/home/step/.step/config`). The main config file `ca.json` will reside here. If you prefer to store config elsewhere (or if using an alternate home dir), adjust this path.                                                                                                                                                                                                                                                                                                                                                          |
| **`step_ca_listen_address`**  | `":8443"`                            | **Network address and port that Step CA will listen on.** The format is `"<address>:<port>"`. By default, it listens on all interfaces (`0.0.0.0`) on port **8443** (a non-privileged port commonly used for internal CA). You can change this to `":443"` for the standard HTTPS port or another port as needed. **Note:** Binding to ports below 1024 (like 443) typically requires root privileges or capabilities — see **Known Issues** if you plan to use a privileged port while running as a non-root user. Also ensure any firewalls allow this port as needed (e.g., open 8443 or 443 to your client networks).                                                                                                                       |
| **`step_ca_dns_names`**       | `[]` (empty list)                    | **List of DNS names for the CA’s certificate.** These are the Subject Alternative Names (SANs) that will be included in the Step CA root certificate (or intermediate certificate) when bootstrapping. Typically, this should include the host’s primary DNS name (e.g., `"ca.example.com"`) and any additional names clients will use to reach the CA. This variable **must** be set (to at least one name) if `step_ca_bootstrap: true`, because Step CA initialization requires a DNS name. If multiple names are provided, they all will be present in the CA certificate.                                                                                                                                                                  |
| **`step_ca_use_vault_ra`**    | `false`                              | **Flag to enable Vault RA mode.** When set to `true`, the role will configure Step CA to use **HashiCorp Vault** as a root certificate authority (Vault **Certificate Authority Service** mode). In this mode, Step CA does **not** generate its own root key/certificate. Instead, it acts as an intermediate CA, requesting signing from Vault’s PKI. The role will skip the `step ca init` bootstrap when this is true, assuming that Vault and its PKI backend are set up separately. You must provide the Vault connection details (see the `step_ca_vault_*` variables below) as well as use an external database (since Vault RA mode typically requires a stateful DB for Step CA).                                                     |
| **`step_ca_vault_address`**   | `""` (empty string)                  | **Vault server address (URL) for RA mode.** For example: `"https://vault.internal:8200"`. This is the URL to the Vault instance that hosts the PKI secrets engine for your CA. Used only if `step_ca_use_vault_ra` is true. Make sure the Step CA host can reach this address and that it’s the correct scheme (`https://`) and port.                                                                                                                                                                                                                                                                                                                                                                                                           |
| **`step_ca_vault_pki_mount`** | `""` (empty string)                  | **Vault PKI mount path to use.** This is the path where the PKI engine is mounted in Vault that will serve as the CA (for example, `"pki_int"` or `"pki/stepca"`). Step CA will use this path to fetch its signing certificate. Required when using Vault RA mode.                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| **`step_ca_vault_role_id`**   | `""` (empty string)                  | **Vault AppRole RoleID for Step CA.** In Vault RA mode, Step CA authenticates to Vault using the AppRole method. You need to create an AppRole in Vault that has permissions to read the PKI engine’s CA cert/issue certs. This variable should be set to the RoleID of that AppRole (a UUID string from Vault). The RoleID is not secret by itself, but treat it carefully.                                                                                                                                                                                                                                                                                                                                                                    |
| **`step_ca_vault_secret_id`** | `""` (empty string)                  | **Vault AppRole SecretID for Step CA.** This is the secret half of the AppRole credentials (essentially the “password” for the RoleID). It is **sensitive** – anyone with this can authenticate to Vault as the AppRole. You should retrieve this securely (for instance, using Ansible Vault or HashiCorp Vault lookup as in the examples) rather than hard-coding it. The role will place this value into the `ca.json` config so Step CA can log into Vault at startup.                                                                                                                                                                                                                                                                      |
| **`step_ca_vault_cacert`**    | `/etc/ssl/certs/ca-certificates.crt` | **CA certificate file path for Vault’s TLS certificate.** Step CA will use this file to verify Vault’s SSL certificate. By default, it points to the system CA bundle (Debian’s collection of trusted root certs). If your Vault is using a certificate signed by a private or internal CA not included in the system bundle, you should provide a path to the appropriate CA certificate file. For example, you might distribute your organization’s CA cert to `/etc/ssl/certs/vault_ca.pem` and set this variable to that path. This ensures Step CA can establish a secure TLS connection to Vault.                                                                                                                                         |
| **`step_ca_db_backend`**      | `"badger"`                           | **Database backend for Step CA’s data.** This setting controls where Step CA stores certificates, keys, and other state. The default `"badger"` uses an embedded on-disk key-value database (BadgerDB) stored under the Step CA directory. Other supported values include `"mysql"` (to use MySQL/MariaDB) or `"postgres"` (for PostgreSQL) as external databases. **Important:** This role currently only templates the connection string for MySQL if you choose a backend other than badger. (It assumes MySQL when not badger.) If you want to use PostgreSQL or another DB, you would need to adjust the config template or contribute a change. Use `"badger"` for a simple standalone deployment, or `"mysql"` for HA/multi-node setups. |
| **`step_ca_db_host`**         | `""` (empty)                         | **Database host address for external DB.** If `step_ca_db_backend` is set to `"mysql"` (or another external DB), this should be the hostname (or IP) of the database server. For MySQL, you can include `:<port>` if not the default 3306, though the template currently assumes 3306. Leave this blank if using the default badger store (it will be ignored).                                                                                                                                                                                                                                                                                                                                                                                 |
| **`step_ca_db_name`**         | `""` (empty)                         | **Database name for Step CA data.** Create a database (schema) in your external DB for Step CA to use (e.g., named `"stepca"`). Provide that name here if using MySQL/Postgres. Not used for badger. Make sure this DB exists prior to running the role (the role does not create databases).                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| **`step_ca_db_username`**     | `""` (empty)                         | **Database username for Step CA.** The user account that Step CA will use to connect to the external database. This user should have appropriate rights on the `step_ca_db_name` (for example, SELECT/INSERT/UPDATE on MySQL tables). Not used for badger. You should set this (and `step_ca_db_password`) in your inventory or Vault if using an external DB.                                                                                                                                                                                                                                                                                                                                                                                  |
| **`step_ca_db_password`**     | `""` (empty)                         | **Database password for the above user.** Password for the Step CA DB account. This is sensitive; do not store it in plain text in a public repo. Use Ansible Vault or a dynamic lookup (e.g., HashiCorp Vault secret lookup as in examples) to supply this. Not used for badger backend. The password will be included in the `ca.json` file for Step CA to connect, so that file must remain protected (which the role ensures via file permissions).                                                                                                                                                                                                                                                                                         |
| **`step_ca_bootstrap`**       | `false`                              | **Whether to bootstrap (initialize) the CA on this run.** When `true`, the role will perform a one-time initialization of Step CA by running `step ca init` under the hood. This generates the root CA (or intermediate if using external root), initial configuration, and default provisioner. Use this for the **first** run on a new CA host. For subsequent runs or if you already have a CA configuration in place (or when using `step_ca_use_vault_ra`), leave this as `false` so you don’t overwrite or reinitialize the CA. In multi-node scenarios, you might enable this on one designated “primary” node to create the CA, and keep it false on secondary nodes.                                                                   |

</details>

<!-- markdownlint-enable MD033 -->

## Tags

This role does not define any special Ansible tags for its tasks. All tasks will run by default when the role is applied. In other words, you cannot selectively skip or run subsets of the **step\_ca** role’s tasks via tags – the role is intended to be executed in full to install and configure the CA. (You can control certain behavior through variables, such as disabling the bootstrap step by leaving `step_ca_bootstrap: false`, but not via Ansible tags.)

## Dependencies

**Role Dependencies:** None. This role does not depend on any other Ansible roles, and the `dependencies` list in its metadata is empty. You can include `step_ca` in your playbook without it automatically pulling in any other roles.

**Collection/Module Dependencies:** All modules used are part of Ansible’s built-in or standard collections for Debian systems. The role uses `ansible.builtin.apt_key`, `apt_repository`, `apt`, etc., which are included with the Ansible distribution (provided you have the `community.general` collection or newer Ansible versions where these are in ansible.builtin). No additional Ansible collections are required for core functionality. However, if you utilize Vault lookups in your inventory (as shown in examples, using `community.hashi_vault.vault` to retrieve secrets), you will need the **community.hashi\_vault** collection installed. That collection is used for fetching Vault secrets (like DB passwords or AppRole IDs) but it’s not directly invoked by this role’s tasks — it would be part of your variable setup.

**External Software/Services:**

* *Smallstep APT Repository:* This role adds an external APT source (`https://dl.smallstep.com/apt`) to install the Step CA packages. Internet connectivity is required on the managed node (or on your apt proxy) to fetch the repository key and packages. If your environment is offline, you should pre-arrange access to the Step CA .deb packages (for example, by hosting an internal mirror or manually downloading the `.deb` files). In an offline scenario, you might skip the repository tasks and use a local `dpkg` to install the packages — that would require modifications to the role or a fork.
* *HashiCorp Vault (optional):* If using `step_ca_use_vault_ra: true`, you must have a Vault server configured **separately**. This includes enabling a PKI secrets engine (for your CA) and setting up an AppRole with appropriate policy. This role does **not** install or configure Vault itself; it assumes Vault is ready and accessible. You should run a Vault role or manual setup prior to applying this role in RA mode. Ensure the Vault address and credentials you provide are correct, and that the Vault’s CA certificate is available if it’s a private CA (see `step_ca_vault_cacert`).
* *Database server (optional):* For an external DB backend (MySQL/PostgreSQL), you need to have that database server running and reachable from the Step CA host. The role does **not** install MySQL/Postgres server or create the database/tables. You should provision the database (and user credentials) ahead of time (for example, using a MySQL/MariaDB role to set up a database named “stepca” and a user). Only once the DB is in place should you run this role with `step_ca_db_backend` and connection info configured. The Step CA service will fail to start if it cannot connect to the database or if credentials are wrong.
* *Systemd:* The managed node must use systemd as its init system (which is true for Debian/Ubuntu). The role installs a systemd unit file and uses `ansible.builtin.service` to enable/start the service. If you attempted to run it on a system without systemd, the service setup would not work.
* *General OS Requirements:* The role will update apt cache and install packages. It assumes the presence of standard utilities (e.g., `apt-key` if needed, though it uses the module for that). There are no other special system requirements aside from enough privileges (the play should run with `become: true` to allow package installs, user creation, and writing to `/etc/systemd`).

In summary, ensure you have internet access for APT (or have a mirror) and that any optional components (Vault, MySQL) are prepared if you intend to use them. Other than that, there are no third-party role or library requirements beyond a standard Ansible environment.

## Example Playbook

Below is a simple example of how to use the `step_ca` role in an Ansible playbook. This playbook will deploy a standalone Step CA on one or more hosts in the **step\_ca\_servers** inventory group, initializing a new CA:

```yaml
- hosts: step_ca_servers
  become: true  # ensure privilege escalation for installation tasks
  vars:
    step_ca_dns_names:
      - "ca.infra.local"           # Primary DNS name for the CA certificate (adjust to your domain)
    step_ca_listen_address: ":8443"  # Listen on port 8443 (default). Change to ":443" if needed (see note below).
    step_ca_bootstrap: true        # Initialize a new CA if none exists
    # step_ca_use_vault_ra: false  # (Optional) Set true to use Vault as CA; provide vault vars if so.
    # step_ca_version: "0.25.1"    # (Optional) pin a specific version of step-ca to install
    # step_ca_cli_version: "0.25.1" # (Optional) pin a specific version of step CLI
  roles:
    - role: step_ca
```

**Notes:**

* **Bootstrap vs. Existing CA:** In this example, `step_ca_bootstrap: true` is set to initialize a new CA. On first run, the role will generate a root certificate and keys. If you are running this role on an already-initialized CA (or a secondary node in a cluster), you should set `step_ca_bootstrap: false` to avoid re-initializing. The role by default leaves bootstrap off to prevent accidental re-gen of CA keys.
* **DNS Names:** Always specify at least one DNS name in `step_ca_dns_names` when bootstrapping. For example, `"ca.infra.local"` might be the hostname or CNAME by which your internal systems will access the CA. You can include multiple names if needed (e.g., alternate names or future domain changes).
* **Privileged Ports:** If you want Step CA to listen on the default HTTPS port 443, you *can* set `step_ca_listen_address: ":443"`. However, note that binding to port 443 while running as a non-root user requires additional steps (the role itself does not set these up). You would need to grant the `step-ca` binary permission to bind low ports (for instance, using `setcap cap_net_bind_service=+ep /usr/bin/step-ca` after installation) or use a port forward/Load Balancer. Alternatively, run Step CA behind a proxy like HAProxy that listens on 443 and forwards to 8443. The above example keeps 8443 to avoid this complication in a demo.
* **Storing Secrets:** In the playbook variables above, sensitive values like passwords are not shown. It’s **highly recommended** to store things like `step_ca_db_password` or `step_ca_vault_secret_id` in an encrypted Ansible Vault or fetch them from a secret manager at runtime. For example, you might have `step_ca_db_password: "{{ vault_stepca_db_password }}"` where `vault_stepca_db_password` is an Ansible Vault variable, or use the HashiCorp Vault lookup as in the inventory examples. This prevents exposing secrets in plain text.
* **Using Vault RA Mode:** To use the role in Vault RA mode, you would set `step_ca_use_vault_ra: true` and provide the Vault details (e.g., `step_ca_vault_address`, `step_ca_vault_role_id`, `step_ca_vault_secret_id`, etc.) typically via group vars or an encrypted file. Additionally, you’d likely set `step_ca_db_backend: "mysql"` (and related `step_ca_db_*` vars) because Vault mode is often combined with an external DB for multi-instance support. In such a case, you usually would *not* set `step_ca_bootstrap: true` (keep it false) because you are not generating a new root – Vault already has the CA. One host might perform an intermediate certificate request from Vault manually (outside this role’s scope) or you ensure the config is in place for all hosts. See **Known Issues and Gotchas** for more about multi-node setups.
* **Post-Deployment:** After running this role (especially with bootstrap), you will have a running CA. You can then use the **`step` CLI** on any host (or the CA host) to issue certificates or configure provisioners. For instance, you might SSH into the CA host (or use Ansible ad-hoc) to run `step ca health` to check status, `step ca certificate <name> <name>.crt <name>.key` to issue a test cert (using the default admin provisioner credentials), etc. These operational steps are outside the automation provided by the role but are typically the next steps in using your new CA.

## Testing Instructions

This role includes (and can be tested with) a **Molecule** scenario for automated testing. Molecule enables you to verify that the role works on a fresh system (using containers or VMs). You can use Molecule to test the **step\_ca** role as follows:

1. **Install Molecule and Docker** on your development machine (if not already installed). Ensure you have Python and pip available, and a running Docker service (for container-based tests). Install Molecule and its Docker driver by running, for example:

   ```bash
   pip install molecule molecule[docker] docker-py testinfra
   ```

   This installs Molecule, the Docker driver, and Testinfra (for writing assertions). Verify that Docker is installed and that your user can run containers (you might need to be in the `docker` group or run with sudo).

2. **Use the provided scenario or initialize a new one:** Check if the role already contains a Molecule scenario (typically in `roles/step_ca/molecule/` directory). This project often provides a default scenario for roles. If present, you can use it directly. If not, you can create one with:

   ```bash
   molecule init scenario -r step_ca -d docker
   ```

   This will set up a `molecule/default` directory for the step\_ca role with a basic `molecule.yml` (which defines a Docker container platform) and a sample converge playbook. You may need to edit `molecule/default/converge.yml` to ensure it includes the `step_ca` role and any necessary variable overrides (for instance, you might set `step_ca_bootstrap: true` and `step_ca_dns_names` in the converge playbook so that the role will actually initialize the CA during the test). The default scenario might already have some of this in place.

3. **Run the Molecule test suite:** Once configured, run Molecule to perform a full test cycle (create container, converge, verify, destroy):

   ```bash
   cd roles/step_ca
   molecule test
   ```

   Molecule will pull up a fresh Docker container (by default, likely a Debian base image), apply the `step_ca` role inside it (this is the *converge* step, equivalent to running our example playbook on that container), then run any verification steps (if tests are defined), and finally destroy the container. By default, if no explicit tests are written, it at least checks that Ansible tasks completed without errors. The scenario is typically configured to use Debian 12 (Bookworm) as the test image to match our supported OS.

4. **Verify the outcome manually (if needed):** If Molecule finishes the converge step, you can manually inspect the container to validate that the role did what it was supposed to. Use Molecule’s login feature to open a shell in the container:

   ```bash
   molecule login -h instance
   ```

   *(Replace "`instance`" with the name of the container instance, if different — it’s defined in `molecule.yml`, often as "instance" or "step-ca-instance").*

   Inside the container, you can run a few checks:

   * Verify **Step CA is installed**: `step-ca version` (should output the version of step-ca installed) and `step version` to check the CLI. You can also do `dpkg -l | grep step-ca` to see the package.
   * Verify the **step user exists**: `id step` (should show a system UID and a group, no login shell).
   * Check **configuration files**: Ensure `/home/step/.step/config/ca.json` exists. You can `cat` this file to see that it has the expected JSON (with the DNS names you set, etc.). Also check that `/home/step/.step/secrets` contains the key (e.g., `root_ca_key` if bootstrapped) and `/home/step/.step/certs` has the root certificate – these would indicate the CA was initialized.
   * Because the container might not run systemd, the **step-ca service** might not be actively running in the container. If the Docker image has systemd enabled (some test images do), you could try `systemctl status step-ca`. Otherwise, Molecule may use a workaround to run the role tasks (like a one-time run). In a container without systemd, the service enabling can be checked by inspecting that the unit file was placed in `/etc/systemd/system/step-ca.service`. You could even manually start the step-ca process (`/usr/bin/step-ca /home/step/.step/config/ca.json --password-file /home/step/ca-pass.txt`) to see if it runs (though password might be needed).
   * If using vault or external DB in the test scenario (which is less common in automated tests), you’d verify connectivity to those. Typically, the default test scenario will use the simplest case (badger DB, bootstrap true) to ensure the role’s basic path works.

   These manual checks are optional but useful for confirming that changes you make to the role don’t break expected behavior.

5. **Iterate and troubleshoot:** If the role didn’t converge (i.e., Ansible threw errors) or if some aspect isn’t as expected, adjust the role or the test scenario and re-run Molecule. You can run `molecule converge` to apply the role again on an existing container (useful during development), or `molecule verify` to rerun tests without recreating the container. Use `molecule destroy` to clean up the test container when you’re done. Molecule’s output will show which tasks changed/failed, helping pinpoint issues. For example, if a task fails due to a missing dependency or wrong variable, you can fix it in the role and `molecule converge` again.

By using Molecule, you can confidently test this role in isolation. The provided scenario (or one you create) typically uses Debian Bookworm; you can test other OS versions by editing the Molecule config (for instance, use an Ubuntu Docker image to verify the role on Ubuntu LTS). This is a good way to ensure compatibility across distributions and catch any platform-specific issues.

## Known Issues and Gotchas

When using the `step_ca` role, be aware of the following common issues, limitations, or quirks:

* **CA Password and Non-Interactive Init:** During bootstrap, Step CA requires setting a password for the new CA’s private key. The role runs `step ca init --non-interactive` and points to a password file (`ca-pass.txt` in the step user’s home). **However, the role does *not* automatically create or populate this password file.** This means out-of-the-box, if no password file exists, the init may fail or prompt (which in non-interactive mode results in failure). In practice, if you set `step_ca_bootstrap: true`, you should ensure the file **`/home/step/ca-pass.txt`** exists **beforehand** with the desired password (the file should be owned by `step:step` and not world-readable). This is a current limitation: the secure handling of the CA password is left to the operator. A workaround for testing is to create the file with a known password (not recommended for production). For production, you might perform the init manually to choose a strong password, or consider using an external KMS integration (Step CA supports cloud KMS plugins) – but that’s outside the role’s scope. *(In short: the role expects a password file to be present for bootstrap. Don’t forget to create it, or the init step may not succeed.)*
* **`step_ca_dns_names` Cannot Be Empty:** If you attempt to bootstrap without providing any DNS names, Step CA’s init will fail (it requires at least one SAN for the root certificate). The default value is an empty list, which is not valid for actual use. Make sure to set `step_ca_dns_names` to at least one hostname. For example, if you forget this, the role might complete all tasks except the `step ca init` (which would be skipped or error out), leaving you with an uninitialized CA. The symptom would be that `ca.json` exists but is nearly empty for the authority section, and no keys/certs were generated. Always define the CA’s DNS name(s) in your inventory or playbook.
* **Re-running Bootstrap (Idempotence):** The role uses a guard (`creates: .../ca.json`) on the init command to avoid re-initializing an already-bootstrapped CA. This means if you run the role once with bootstrap enabled and it succeeds, subsequent runs will skip the `step ca init` (since `ca.json` is now present). This is good for idempotence, but note that if you intentionally delete or move `ca.json`, a subsequent run would attempt to init *again*, potentially overwriting your CA (not a typical scenario, but be cautious if manually cleaning up files). In multi-node setups, you generally only want one node to bootstrap; others should skip it. Coordinate the `step_ca_bootstrap` variable accordingly (e.g., use an inventory variable `step_ca_primary: true` on one host and set `step_ca_bootstrap: "{{ step_ca_primary | default(false) }}"` as in the provided cluster playbook).
* **Binding to Privileged Ports:** As mentioned, running Step CA on port 443 (or any port <1024) while using a non-root user requires extra system configuration. The role does not currently automate this. If you set `step_ca_listen_address: ":443"` (or similar), the service will likely **fail to start** with a permission error (`bind: permission denied`) because the `step` user cannot bind to 443 by default. Solutions include:

  * Running `sudo setcap cap_net_bind_service=+ep /usr/bin/step-ca` on the host after installation (this grants the binary permission to open privileged ports). You could automate this with an additional task or a small role of your own.
  * Using a proxy or redirect: e.g., configure **HAProxy** or Apache/Nginx to listen on 443 and forward to Step CA’s 8443.
  * Running Step CA as root (not recommended for security).

  Until the role possibly includes an option for setting capabilities, you’ll need to handle one of these manually if 443 is required. Many choose to run on 8443 internally and handle any external port mapping at the network or LB level.
* **Vault RA Mode Requires Prep:** If `step_ca_use_vault_ra: true`, ensure you have completed the Vault setup **before** running this role. You need a Root or Intermediate CA configured in Vault’s PKI engine and an AppRole for Step CA. Common pitfalls include missing policy privileges (Step CA will be denied access to read or sign, causing it to error on startup) or incorrect RoleID/SecretID. If Step CA fails to start in Vault mode, check the journal or logs – it might show Vault authentication errors or inability to fetch the certificate. This usually means either the credentials are wrong or not authorized. Also, Vault must be reachable from the Step CA host (network connectivity, correct `step_ca_vault_address`, and possibly proper TLS trust via `step_ca_vault_cacert`). These are not issues with the role per se, but operational gotchas when using Vault. It’s wise to test connectivity (e.g., from the Step CA host, try `curl` to the Vault address or use the Vault CLI with the AppRole credentials) prior to deploying.
* **External Database not Initialized by Role:** When using an external DB (MySQL), note that the Step CA application will attempt to use the provided database and will create its own tables if the database is empty. However, the **database itself** and the user must exist and be granted privileges. If you forget to create the DB or user, Step CA will log connection errors or “unknown database”. You’ll need to go back and create the database. Also ensure the firewall between the Step CA host and DB is open (default MySQL port 3306, or whichever port you use).
* **Multi-Node/Clustering Coordination:** This role does not magically cluster Step CA instances. If you run the role on two or more hosts with the same configuration, each will set up a CA service. For HA, you must ensure they share the same underlying CA and data:

  * **Using Vault & MySQL:** This is the recommended approach for multi-node Step CA. All nodes point to the same Vault CA (so they have the same signing authority) and the same MySQL database (so issued certificates and revocation records are consistent). In this case, you would deploy the role to all nodes with `step_ca_use_vault_ra: true` and identical vault/db settings. Only one node needs to do the initial bootstrap of writing the config (others could even skip if files are the same, but this role will template `ca.json` on each). After deployment, you should have multiple Step CA instances all serving the same CA. You’ll want a load balancer in front (see **Cross-Referencing**). The known gotcha: if Vault’s AppRole SecretID is single-use, you must generate a unique SecretID for each node (since once one node uses it, it’s consumed). Vault allows creating multiple SecretIDs for the same role – supply each host its own via inventory.
  * **Standalone CA on multiple hosts:** If you are *not* using Vault and attempt to bootstrap multiple nodes, you will end up with independent root CAs on each (which is usually not what you want). To have a true cluster sharing one CA without Vault, you would have to manually copy the root key and cert from one node to the others (ensuring `~step/.step` contents are identical) and use a shared DB. This process is manual and error-prone – it’s beyond what the role does. Therefore, if you require multi-node CA and don’t want to use Vault, proceed with extreme caution: initialize one node, then distribute its `/home/step/.step` to the others *before* starting them. This is not handled by the role, and if done incorrectly can lead to duplicate or mismatched CA states.
  * In summary, **the role doesn’t coordinate cluster state**; it assumes a single-node deployment unless you deliberately configure a shared backend. Use Vault RA or shared DB carefully. The provided `deploy_step_ca_cluster.yml` playbook in this repo is a guide: it hints at marking one host as primary (for bootstrap) and others as secondary.
* **Not Tested on Non-Debian OS:** As noted earlier, running this on RHEL/CentOS will not work without modifications. Common issues would include the APT tasks failing and the service not being set up properly. If you require Step CA on those systems, consider either containerizing Step CA (and use Docker/Podman outside of Ansible’s scope) or writing a separate role for those OS families. This role assumes Debian-based conventions throughout.
* **No Provisioner/Client Setup in Role:** After this role runs, you have a CA but no client certificates have been issued yet. It’s expected that you or another automation handles provisioning end-entity certs. Remember that Step CA, by default, creates a provisioner named "admin" (an initial authority to get tokens) when bootstrapped. The password you set for the CA key is also used to unlock the admin provisioner. A common gotcha is forgetting that password, which means you can’t easily use the `step` CLI to get a token to issue certs. Make sure you record the CA password (or use a known one for admin operations) so you can generate tokens or configure automated enrollment. This is more of an operational tip: the role doesn’t expose the provisioner details, but you should be aware of them to actually use your CA.
* **Upgrades and Idempotency:** The role installs the latest version by default. If a new version of step-ca is released and you re-run the role, APT might upgrade the package (which will trigger a service restart). This is generally fine. Just be aware that upgrading the CA in place will reload it – ideally do this during a maintenance window as it will temporarily stop the CA service. Also, if the CA’s configuration format changes between versions, you might need to adjust your variables or template (not common, but worth checking the Step release notes on major upgrades). So far, upgrades within the same major series are usually safe and backward-compatible.
* **Logging and Troubleshooting:** If something isn’t working, check the Step CA logs. By default, since we run via systemd, you can do `journalctl -u step-ca -f` to tail the logs. This will show things like “listening on address ...”, or errors such as inability to connect to DB or Vault, or configuration JSON parse issues, etc. Many “it doesn’t work” situations can be clarified by reading those logs. The role itself might not fail the play if, say, the service starts but then encounters runtime errors (that’s outside Ansible’s purview). So always verify the service is actually up and healthy. You can use `step ca health --ca-url https://<your-ca>:<port>` to check health via CLI as well.

## Security Implications

Deploying a Certificate Authority comes with significant security considerations. This role sets up Step CA following security best practices, but you as the operator should be mindful of the following:

* **Least-Privilege Service User:** The role creates a dedicated user **`step`** (with group `step`) that has no login shell and is not a sudoer. The Step CA process runs under this account, meaning it doesn’t have root privileges. This is a crucial security measure – if the CA service were compromised, the attacker would not immediately gain root access to the host. Keep this `step` user confined to just running Step CA. Do not use it for interactive sessions or to run other processes. All files related to the CA (configs, keys, DB files) are owned by `step:step`. The config directory is set 0750 and private keys 0600, meaning other non-root users on the system cannot read them. If your security policy requires even stricter permissions (e.g., disallow `other` read on certain files), you can adjust them as needed, but the defaults are reasonably secure. Remember that the Step CA process needs read (and sometimes write) access to its own files, so don’t make them completely inaccessible to `step`.
* **Protection of CA Private Key:** The root (or intermediate) CA private key is the most sensitive piece of data on the host. By default, it resides in `/home/step/.step/secrets/` (when bootstrapped) and is encrypted with the password you provided at init. Ensure that this password is strong and kept secret. Physical and system security of the CA host is paramount – if an attacker obtains the encrypted key and the password, they control your CA. Consider additional safeguards such as storing the key in an HSM or using cloud KMS integration (Smallstep offers plugins for that) if this is a long-term CA. At minimum, restrict access to the CA host and regularly back up the key in a secure, offline location (see *Data Backup* below).
* **Open Ports and Network Access:** Step CA by default listens on all network interfaces (`0.0.0.0`) on the specified port (8443 by default, or 443 if changed). This means any system that can reach that host’s IP can attempt to connect to the CA service. While Step CA requires authentication for most operations (you can’t get a cert without a token or client proving control via ACME, etc.), you should still restrict access:

  * Use a firewall (like the **ufw** role or cloud security groups) to allow access to the CA port only from known networks or hosts. For example, if only your internal application servers should request certificates, only those subnets should be allowed to connect to Step CA’s port. If running in Vault RA mode, Step CA might be part of a larger infra – ensure it’s not exposed to the public internet unless absolutely necessary.
  * If the CA serves an internal domain (e.g., \*.infra.local), there’s usually no reason for external addresses to hit it. Closing the port to the outside reduces attack surface. Even internally, consider whether all hosts need to reach the CA or just certain ones (and scope firewall rules accordingly).
  * Monitor the port for unexpected connections. Step CA logs all certificate requests and failures; unusual spikes could indicate misuse or an attempted attack.
* **TLS Communication:** All traffic to Step CA is HTTPS (it uses TLS for the API). During bootstrap, a self-signed root certificate is created for the CA. Clients need this root certificate to trust the CA. One security implication is distributing this root certificate to your clients securely. Make sure you **securely deploy the CA’s root certificate** to all client machines that should trust it (this can be done via configuration management or manually). Anyone who has the root cert can trust certs issued by your CA – which is intended for your environment, but you wouldn’t want an untrusted party to just grab your root cert and start trusting it (that’s less of a risk, more of a note: the trust is established by possession of the root cert).

  * If you used Vault RA mode, your Step CA’s signing cert is an intermediate signed by Vault’s root. In that case, you’ll need to distribute the Vault root CA cert (and possibly the intermediate if clients don’t get it automatically) to your clients as trust anchors.
  * The communications between Step CA and clients (for ACME or API calls) are encrypted, but initially clients won’t trust the CA until they have the root cert. Make sure to use secure channels to provide the root (for example, out-of-band or via a trusted config management, not via an unauthenticated download).
* **Vault Credentials in Config:** When using Vault RA, the `ca.json` contains sensitive credentials (the RoleID and SecretID for AppRole). This is effectively like an application secret/password. The role already ensures `ca.json` is 0600 owned by `step`, so no other user can read it. Maintain this permission. Be cautious about backups or copying this file, as it could grant access to Vault. It’s a good practice to periodically rotate the SecretID (Vault AppRole allows creating new SecretIDs and revoking old ones), especially if you suspect it might have been exposed. If you do rotate it, you’ll need to update the `step_ca_vault_secret_id` variable and re-run the role (or manually edit `ca.json` and restart step-ca) to use the new credential.
* **Database Credentials:** Similarly, if using an external DB, the username/password are in `ca.json`. Treat that file as sensitive. The DB credentials ideally should only have access to the Step CA’s specific database, and not be a superuser. That way, even if someone somehow read them, they can’t do much outside the scope of CA data. Still, to an attacker, read access to the DB could reveal issued certificates or allow tampering (though Step CA might sign them, etc.). Protect those credentials and consider enabling TLS on database connections if your DB supports it, since Step CA might be sending data over the network to the DB.
* **Service Availability & Revocation:** A private CA can become a critical service if your infrastructure relies on it for issuing or renewing certificates. Downtime or compromise can have wide impact (e.g., services can’t renew expiring certs). Some security considerations:

  * **Availability:** If you require high availability, deploy multiple Step CA instances with a load balancer (and Vault/DB as discussed). The security angle here is ensuring the failover is seamless and that all instances are equally secure (don’t, for example, leave one node with default passwords while others are properly configured).
  * **Revocation and CRL/OCSP:** Step CA can maintain a CRL (certificate revocation list) and serve OCSP responses for revoked certificates. If you plan to use these features, ensure the CRL endpoint or OCSP is reachable to your clients and consider the implications: e.g., if the CA is down, clients might treat OCSP as failing (depending on soft/hard fail configuration). Also, revocation requires discipline in managing the server (to issue `step ca revoke` when needed). This role doesn’t set up any automated revocation checks elsewhere, so it’s on you to integrate that into your security workflow.
  * **Auditing:** Keep an eye on who is requesting certificates. Step CA’s logs will show which provisioner was used and which names were issued. You might want to aggregate these logs to a SIEM or log management system. Unusual certificate issuance (e.g., an unexpected hostname or a large number of certs issued in a short time) could indicate misuse or compromise of a provisioner credential.
* **Keeping Step CA Up-to-date:** Step CA is actively maintained; updates may include security fixes. Use the role (with `step_ca_version: latest` by default) to upgrade when new releases come out, after testing. An outdated CA could have vulnerabilities that put your PKI at risk. Because this role makes updating easy (just rerun it to get latest from APT), you should plan to do that periodically. Always backup your CA data before major upgrades.
* **Backups and Disaster Recovery:** The security of your CA is not just about preventing unauthorized use, but also preserving it in the face of failures. Make regular, secure backups of:

  * The CA certificate and private key (in the case of standalone CA, that’s under `/home/step/.step` – you might back up the entire `.step` directory excluding the `db` if using badger, or including a DB dump if using MySQL).
  * If using badger (embedded DB), definitely back up the `~/.step/db` directory too, as it contains issuance records (though the CA can operate without them in a pinch, you’d lose tracking of issued certs and CRL).
  * Store backups encrypted and offline if possible. Remember that anyone with the root key (even if encrypted with a password) could potentially brute force it if they obtained it, so treat backups with the same level of security as the live key. Using Ansible Vault to encrypt backup archives or storing them in a secure vault is recommended.
  * Test your recovery process: simulate what happens if the CA server is lost. You should be able to restore the files on a new server, re-deploy the role with `step_ca_bootstrap: false` (since you already have the CA files), and get it running with the preserved identity.
* **Integration with Systems:** Finally, consider the security of how clients obtain certificates. If you use ACME protocol (Step CA supports ACME), ensure you’ve properly validated domain ownership (Step CA will need to be configured with provisioners that validate challenges). If you use OIDC or SSO provisioners for client auth, ensure those connections are secure (e.g., the OIDC tokens have limited scope, etc.). These are beyond the scope of the role, but worth mentioning: running an internal CA means you’re taking on the responsibility to enforce that only authorized systems get certs. Plan your provisioners and authorization models accordingly (least privilege, short-lived certificates, etc., as appropriate for your environment).

In summary, this role establishes a secure baseline (non-root service, TLS by default, no open firewall by default, etc.), but maintaining a secure CA requires ongoing vigilance: control network access, protect credentials, audit usage, and have a recovery plan. A compromise of your CA could undermine your entire security infrastructure, so treat this system with a high degree of care (similar to how you’d treat a production database or any critical security service).

## Cross-Referencing

Within this repository, several other roles and tools can complement the **Step CA** role or be used in tandem to create a full-featured security infrastructure:

* **Vault (HashiCorp Vault) Role** – If you plan to use Step CA in *Vault RA mode*, you will need to set up Vault’s PKI backend and an AppRole for Step CA. The **vault** role in this repository can help automate Vault installation and configuration. In particular, look for tasks or sub-roles related to PKI: for example, some roles (like `vault/tasks/pki_ra.yml` and `pki_intermediate.yml`) can initialize a root CA and an intermediate CA in Vault. You could use those to prepare Vault, then use `step_ca` to launch Step CA pointed at that intermediate. Using the Vault role ensures that Vault is properly sealed/unsealed, the PKI engine mounted, and your AppRole credentials created securely, which you then plug into this role’s variables.
* **HAProxy (Load Balancer) Role** – In scenarios where you deploy multiple Step CA instances for high availability, you’ll likely want a single endpoint for clients. The **haproxy** role can set up an HAProxy load balancer in front of your CA nodes. For example, you could configure HAProxy to listen on port 443 and route incoming ACME or API requests to two or more Step CA backend servers on port 8443. HAProxy can also handle TLS termination if needed (though in many cases you might let Step CA handle TLS and just pass through). Combining HAProxy with **keepalived** (see below) can further eliminate single points of failure. The HAProxy role documentation provides details on how to define backend pools; you would list your Step CA servers in a backend, enabling load-balanced round-robin or failover as appropriate.
* **keepalived_setup Role** – This role (if present in the repository) helps configure Keepalived for VRRP, which is often used to provide a floating IP for high availability. If you deploy HAProxy on two nodes (active-passive), Keepalived can ensure that the virtual IP moves to the surviving node if one fails. In the context of Step CA, this means the CA’s front-end IP remains reachable even if one LB node goes down. While not directly related to Step CA, using **keepalived_setup** alongside the HAProxy role is a common pattern for HA setups in this repo.
* **UFW (Firewall) Role** – The **ufw** role can manage Ubuntu’s uncomplicated firewall (or similar roles for Debian iptables/nftables). After deploying Step CA, it’s prudent to lock down access as discussed. The UFW role allows you to automate firewall rules. For instance, you could allow TCP/8443 from only certain IP ranges (your office, your server subnet, etc.) and deny it from others. If the Base role (common hardening) is used, it might already incorporate some firewall settings. Use UFW role to specifically tailor access for the CA service. This is easier and less error-prone than manual firewall config and can be version-controlled as code.
* **letsencrypt_setup Role** – If your use-case for certificates leans towards publicly-trusted certs (e.g., for public websites), you might consider Let’s Encrypt instead of a private CA. The **letsencrypt_setup** role in this repository (and related ones, such as `letsencrypt_godaddy` for DNS challenges with GoDaddy) can automate obtaining certificates from Let’s Encrypt. This is somewhat an alternative to Step CA: for public-facing services, using ACME with Let’s Encrypt can be ideal. For internal services, Step CA is great. In some environments you might use both (Step CA for internal TLS, Let’s Encrypt for external TLS). These roles can coexist. For example, you could use Step CA to issue an internal wildcard cert for `.internal.example.com` while using letsencrypt_setup to get a cert for your public `.example.com` services. Keep in mind, Step CA itself can act as an ACME server for internal ACME flows, but those will only be trusted internally.
* **Base/System Hardening Roles** – As a CA is a critical piece of infrastructure, you should ensure the underlying system is well-secured and maintained. The **base** role (baseline configuration) is often applied to all hosts, including your CA server. It takes care of things like OS updates, minimal services, fail2ban, etc. Ensure your CA host benefits from these measures: an unpatched CA host is a ripe target. The base role, as described in its documentation, includes automatic updates (if enabled), removal of unnecessary packages, and might also include firewall basics. It’s recommended to include the base (or similar hardening roles) in your playbook before the `step_ca` role. That way, by the time Step CA is installed, the system is already in a good state (fully updated, with basic security policies in place).
* **Backup/Recovery Roles or Scripts** – While there might not be a role specifically called “step_ca_backup,” this repository contains backup roles for other services (databases, etc.). You can leverage similar strategies for Step CA. For example, if you have a **borgbackup** role or an **rsnapshot** role (not sure if included here, but as an idea), consider applying it to the CA host to periodically back up `/home/step/.step` (and perhaps MySQL dumps if using external DB). Even a generic **backup** role or manual cron + `tar` could do, but having it in Ansible means it’s documented and repeatable. Cross-reference: the MinIO role documentation mentions using “backup roles in this repository” – likely there are some generic backup utilities roles that could be repurposed. Ensure any backups of CA data are encrypted and access to them is restricted (you might integrate with Vault to store backup encryption keys or use GPG).
* **Client Roles that use the CA** – Look at other roles that might consume certificates. For instance, roles for web servers (Apache/Nginx), load balancers, etc., often have options for providing certificates. Those could potentially be integrated with Step CA by requesting certs from your CA. While this integration isn’t automatically handled by this role, you might design your playbooks such that after `step_ca` is deployed, other roles fetch certificates (perhaps using the Step CLI or ACME). For example, a **jenkins_server** role might have a var for SSL cert. You could obtain an internal cert via Step CA and feed it to that role. Or some roles might directly support running an ACME client – if so, you could point that ACME client to your Step CA ACME directory URL. These are advanced integrations but worth noting as a possibility.

By using these complementary roles, you can build a robust ecosystem: a hardened CA server issuing certs, with Vault providing a root of trust and failover, HAProxy ensuring availability, and firewall rules protecting access. Always refer to each role’s documentation for specifics on usage. The Step CA role is typically a central piece in the security puzzle, and the above-mentioned roles help in surrounding it with the necessary supporting infrastructure.
