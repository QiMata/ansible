#!/usr/bin/env python3
"""
APT Mirror Alert Manager
Generated by Ansible - Do not edit manually
"""

import os
import json
import yaml
import smtplib
import requests
from datetime import datetime
from email.mime.text import MimeText
from email.mime.multipart import MimeMultipart

class AlertManager:
    def __init__(self, config_file='/opt/apt-mirror-alerts/config.yml'):
        with open(config_file, 'r') as f:
            self.config = yaml.safe_load(f)
        
        self.state_file = '/var/lib/apt-mirror-alerts/alert_state.json'
        self.load_state()
    
    def load_state(self):
        """Load alert state to prevent spam"""
        try:
            if os.path.exists(self.state_file):
                with open(self.state_file, 'r') as f:
                    self.state = json.load(f)
            else:
                self.state = {}
        except Exception:
            self.state = {}
    
    def save_state(self):
        """Save alert state"""
        try:
            os.makedirs(os.path.dirname(self.state_file), exist_ok=True)
            with open(self.state_file, 'w') as f:
                json.dump(self.state, f)
        except Exception as e:
            print(f"Failed to save state: {e}")
    
    def should_send_alert(self, alert_type, message_hash):
        """Check if we should send this alert (debouncing)"""
        now = datetime.now().timestamp()
        key = f"{alert_type}_{message_hash}"
        
        # Default cooldown periods
        cooldowns = {
            'sync_failure': 3600,  # 1 hour
            'storage_warning': 1800,  # 30 minutes
            'storage_critical': 900,  # 15 minutes
            'mirror_unavailable': 600,  # 10 minutes
            'service_down': 300  # 5 minutes
        }
        
        cooldown = cooldowns.get(alert_type, 1800)
        
        if key in self.state:
            if now - self.state[key] < cooldown:
                return False
        
        self.state[key] = now
        self.save_state()
        return True
    
    def send_email_alert(self, subject, message):
        """Send email alert"""
        if not self.config.get('email', {}).get('enabled', False):
            return False
        
        try:
            email_config = self.config['email']
            
            msg = MimeMultipart()
            msg['From'] = email_config['from']
            msg['To'] = email_config['to']
            msg['Subject'] = f"[APT Mirror Alert] {subject}"
            
            msg.attach(MimeText(message, 'plain'))
            
            server = smtplib.SMTP(email_config['smtp_server'], email_config['smtp_port'])
            if email_config.get('use_tls', False):
                server.starttls()
            if email_config.get('username'):
                server.login(email_config['username'], email_config['password'])
            
            server.send_message(msg)
            server.quit()
            return True
        except Exception as e:
            print(f"Failed to send email: {e}")
            return False
    
    def send_webhook_alert(self, subject, message):
        """Send webhook alert"""
        webhook_url = self.config.get('webhook_url')
        if not webhook_url:
            return False
        
        try:
            payload = {
                'subject': subject,
                'message': message,
                'timestamp': datetime.now().isoformat(),
                'hostname': os.uname().nodename,
                'service': 'apt-mirror'
            }
            
            response = requests.post(webhook_url, json=payload, timeout=10)
            return response.status_code == 200
        except Exception as e:
            print(f"Failed to send webhook: {e}")
            return False
    
    def send_slack_alert(self, subject, message):
        """Send Slack alert"""
        slack_webhook = self.config.get('slack_webhook')
        if not slack_webhook:
            return False
        
        try:
            payload = {
                'text': f"*{subject}*\n{message}",
                'username': 'apt-mirror-bot',
                'icon_emoji': ':warning:'
            }
            
            response = requests.post(slack_webhook, json=payload, timeout=10)
            return response.status_code == 200
        except Exception as e:
            print(f"Failed to send Slack alert: {e}")
            return False
    
    def send_alert(self, alert_type, subject, message):
        """Send alert through all configured channels"""
        message_hash = hash(message) % 10000
        
        if not self.should_send_alert(alert_type, message_hash):
            return
        
        enhanced_message = f"""
Alert Type: {alert_type}
Timestamp: {datetime.now().isoformat()}
Hostname: {os.uname().nodename}

{message}

---
This is an automated alert from APT Mirror monitoring system.
"""
        
        success = False
        
        # Try email
        if self.send_email_alert(subject, enhanced_message):
            success = True
        
        # Try webhook
        if self.send_webhook_alert(subject, enhanced_message):
            success = True
        
        # Try Slack
        if self.send_slack_alert(subject, enhanced_message):
            success = True
        
        if success:
            print(f"Alert sent: {subject}")
        else:
            print(f"Failed to send alert: {subject}")

# CLI interface
if __name__ == "__main__":
    import sys
    
    if len(sys.argv) < 4:
        print("Usage: alert_manager.py <alert_type> <subject> <message>")
        sys.exit(1)
    
    alert_type = sys.argv[1]
    subject = sys.argv[2]
    message = sys.argv[3]
    
    manager = AlertManager()
    manager.send_alert(alert_type, subject, message)
