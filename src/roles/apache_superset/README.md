# Ansible Role: Apache Superset

*Ansible role for installing and configuring **Apache Superset**, an open-source data exploration and visualization platform.*

**Table of Contents**

* [Overview](#overview)
* [Supported Operating Systems/Platforms](#supported-operating-systemsplatforms)
* [Role Variables](#role-variables)
* [Tags](#tags)
* [Dependencies](#dependencies)
* [Example Playbook](#example-playbook)
* [Testing Instructions](#testing-instructions)
* [Known Issues and Gotchas](#known-issues-and-gotchas)
* [Security Implications](#security-implications)
* [Cross-Referencing](#cross-referencing)

## Overview

The **Apache Superset** role sets up the Superset data visualization web application on a target host. Apache Superset is a Flask-based web UI for exploring and visualizing data, with a rich set of charts and dashboards. This role automates the installation of Superset (via pip in a Python 3 virtual environment) and configures it to run as a systemd service using Gunicorn (a WSGI web server) by default. It creates a dedicated system user (`superset`) with no login shell to run the service, installs required system libraries (for Python build and database drivers), and generates the Superset configuration file with your specified settings (database connection URI, secret key, optional Redis/Celery URLs, feature flags, etc.). The role also initializes the Superset metadata database (applying migrations) and creates an administrator user on first run (using credentials provided by variables). Optionally, you can load example dashboards and data for demo or development by enabling the examples flag.

In a typical deployment, Superset requires a **metadata database** to store dashboards, charts, and user accounts (by default this role uses a local SQLite file, but you can point it to an external PostgreSQL/MySQL database for production). Superset's web server will listen on a configurable port (default **8088** on all interfaces) and should be secured behind a proxy or firewall if exposed publicly (no TLS is configured by this role). Superset can also use **Redis** as a caching layer and message broker for background tasks (via Celery). The diagram below illustrates the components and their interactions in a Superset deployment:

```mermaid
flowchart LR
    User[Web Browser] --> |HTTP (port 8088)| Superset[[Apache Superset Service]]
    Superset --> |SQLAlchemy| MetadataDB[(Metadata Database)]
    Superset --> |Optional Cache| Redis[(Redis Cache)]
    Superset -->|Async jobs| CeleryWorker[Superset Celery Worker]
    CeleryWorker --> |Broker (Redis/RabbitMQ)| Redis
```

After applying this role, the Superset service will be up and running as a daemon (accessible on the configured port with the default *admin*/*CHANGEME* credentials if not overridden). In most scenarios, you will want to adjust the defaults (particularly the admin password, secret key, and database URI) for security and persistence. You may also consider deploying complementary services such as a dedicated metadata database (PostgreSQL, etc.) and a reverse proxy or load balancer in front of Superset for production use. See the **Cross-Referencing** section for related roles and recommendations.

## Supported Operating Systems/Platforms

This role is tested on and designed for **Debian-based** Linux distributions:

* **Debian**: 11 (*Bullseye*) and 12 (*Bookworm*)
* **Ubuntu**: 20.04 LTS (*Focal*) and 22.04 LTS (*Jammy*)

Other Debian derivatives may work if they use `apt` and have similar package names. The role uses APT for package management and assumes Python 3 is available, so non-Debian systems (RHEL, CentOS, Alpine, etc.) are **not supported** without modification. Ensure you run this role on a supported OS to avoid compatibility issues with package names and systemd service configuration.

## Role Variables

<details><summary>Click to see default role variables.</summary>

| Variable                                  | Default Value                                         | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| ----------------------------------------- | ----------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **`superset_version`**                    | "latest"                                            | Version of **Apache Superset** to install (via pip). The role will install this specific version of the `apache-superset` Python package in the virtual environment. By default it uses "latest", which pulls the newest available release from PyPI. Pin this to a specific version for repeatable deployments.                                                                                                                                                                                                                                                                                                    |
| **`superset_user`**                       | "superset"                                          | System username under which Superset will run. The role creates this user (and group) if not present, with no login shell and no home directory. Running the service as a dedicated unprivileged user enhances security (isolating Superset from other processes).                                                                                                                                                                                                                                                                                                                                                    |
| **`superset_group`**                      | "superset"                                          | System group for Superset. Typically the same name as the user. Files and processes for Superset will be owned by this group.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| **`superset_install_dir`**                | "/opt/superset"                                     | Path to the main installation directory for Superset. The role will create this directory to hold the application files and virtual environment.                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| **`superset_venv_dir`**                   | "{{ superset_install_dir }}/venv"                   | Path to the Python virtual environment directory where Superset and its Python dependencies will be installed. By default, this is a `venv` directory under the install path. All pip installations (Superset itself and any additional packages) go into this venv.                                                                                                                                                                                                                                                                                                                                                  |
| **`superset_config_dir`**                 | "/etc/superset"                                     | Directory for Superset configuration and related files. A Python config file (`superset_config.py`) will be placed here. The role ensures this directory exists with proper ownership (`superset:superset`) and permissions (default 0750).                                                                                                                                                                                                                                                                                                                                                                           |
| **`superset_config_path`**                | "{{ superset_config_dir }}/superset_config.py"      | Full path to the Superset configuration file. The role templates this file from `superset_config.py.j2` into the given path. You typically do not change this path; instead, adjust `superset_config_dir` if a different location is needed.                                                                                                                                                                                                                                                                                                                                                                          |
| **`superset_system_packages`**            | *(see defaults)*                                      | List of system packages to install via APT before installing Superset. These include build tools and libraries required for Superset's Python dependencies (e.g., GCC, Python dev headers, SSL and LDAP libs, database client libs). By default this includes packages like **build-essential**, **libssl-dev**, **libffi-dev**, **python3-dev**, **python3-pip**, **libsasl2-dev**, **libldap2-dev**, **default-libmysqlclient-dev**, **libpq-dev**. The role will install all listed packages to ensure that pip installations (especially database drivers) succeed.                                               |
| **`superset_additional_python_packages`** | `[]` (empty list)                                     | Additional Python packages to install in the Superset virtual environment. Use this to specify database drivers or other Python libraries needed by Superset (beyond its default requirements). For example: `['psycopg2-binary', 'mysqlclient']` to support PostgreSQL or MySQL connections. These will be installed via pip *after* Superset is installed. Leave it empty if not needed.                                                                                                                                                                                                                            |
| **`superset_database_uri`**               | "sqlite:////{{ superset_install_dir }}/superset.db" | SQLALCHEMY connection URI for Superset's metadata database. By default, this uses a local SQLite database file (`superset.db` in the install dir) for a quick out-of-the-box setup. **Note:** SQLite is not recommended for production use or multi-user environments. In production, you should set this to a proper database URI (e.g., PostgreSQL or MySQL) that Superset can use to store its metadata. Make sure the database is created and accessible; the role will run migrations (`superset db upgrade`) against this URI.                                                                                  |
| **`superset_secret_key`**                 | "CHANGEME"                                          | Flask *SECRET_KEY* for Superset. This key is used for securely signing session cookies and other cryptographic components. **Change this to a long, random value** in production (you can use Ansible Vault to keep it secret). The default is a placeholder "CHANGEME" which is **not secure**. All Superset instances behind the same load balancer should share the same secret key (if you have multiple instances) to allow consistent session handling.                                                                                                                                                      |
| **`superset_admin_username`**             | "admin"                                             | Username for the initial admin account that the role will create in Superset. You can change this if you prefer a different admin name. This account is created only the first time the role runs (a marker file is used to avoid re-creating on subsequent runs).                                                                                                                                                                                                                                                                                                                                                    |
| **`superset_admin_password`**             | "CHANGEME"                                          | Password for the initial admin user. **Change this to a secure password** for any real deployment (the default is a placeholder). It's recommended to override this (for example, via an encrypted variable in Ansible Vault) so that your Superset admin account is secured.                                                                                                                                                                                                                                                                                                                                         |
| **`superset_admin_email`**                | "admin@example.com"                                 | Email address for the initial admin account (used by Superset for user management purposes). You can set this to a real email if needed.                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| **`superset_admin_firstname`**            | "Superset"                                          | First name for the initial admin user's profile.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| **`superset_admin_lastname`**             | "Admin"                                             | Last name for the initial admin user's profile.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| **`superset_load_examples`**              | `false`                                               | Whether to load the example dashboards and data that come with Superset. If `true`, after installation the role will run `superset load_examples` to populate some sample charts, dashboards, and datasets. This is useful for demo or learning environments. In production, this is usually `false` (to avoid cluttering with demo data). You can safely leave it `false` and later run the command manually if needed.                                                                                                                                                                                              |
| **`superset_use_gunicorn`**               | `true`                                                | Whether to use **Gunicorn** to run the Superset web server. By default this is `true` and the systemd service will launch Superset via Gunicorn (providing better performance and robustness for production). If set to `false`, you would need to adjust how Superset is run (the role's provided service assumes Gunicorn). Generally you should leave this `true` for production deployments.                                                                                                                                                                                                                      |
| **`superset_gunicorn_workers`**           | `4`                                                   | Number of Gunicorn worker processes to run for the Superset service. More workers can handle more concurrent requests but will consume more memory. Tune this based on the server's CPU cores and load. Default is 4, which is a reasonable starting point for a small server.                                                                                                                                                                                                                                                                                                                                        |
| **`superset_gunicorn_bind`**              | "0.0.0.0:8088"                                      | The address and port for Gunicorn to bind to. By default, Superset will listen on port **8088** on all network interfaces. You can change this if you want Superset on a different port or bound to localhost only (e.g., "127.0.0.1:8088" if you plan to put a reverse proxy in front and don't want Superset accessible externally). Ensure this port is allowed through your firewall or security group if you need external access.                                                                                                                                                                             |
| **`superset_redis_url`**                  | "" (empty string)                                   | Connection URL for a Redis instance, if you want Superset to use Redis for caching results (and potentially as a Celery broker). If provided, the role will configure Superset to use Redis Cache (e.g., set `CACHE_TYPE` and `CACHE_REDIS_URL`). Example format: "redis://<hostname>:6379/0". Leave it empty to use the default cache (which is an in-memory cache, not suitable for multi-process or multi-instance setups).                                                                                                                                                                                      |
| **`superset_celery_broker_url`**          | "" (empty string)                                   | URL for the Celery message broker. If you want to enable asynchronous tasks in Superset (for long-running queries, email reports, etc.), set this to a broker URL (Redis or RabbitMQ, for example). When provided, the Superset config will enable Celery by setting `CELERY_BROKER_URL` and `RESULT_BACKEND` to this value. Example: "redis://<hostname>:6379/1" or "amqp://user:pass@rabbitmq-host:5672/vhost". **Note:** The role does *not* automatically run a Celery worker (see **Known Issues** below); you'll need to start the worker process (e.g., via the provided service template or other means). |
| **`superset_feature_flags`**              | `{}` (empty dict)                                     | A dictionary of feature flags to enable or disable specific Superset features. By default this is empty (all features default to Superset's internal settings). You can set key/value pairs here to turn on experimental features or toggles – the role will merge them into the config as `FEATURE_FLAGS` entries. For example: `{"DASHBOARD_NATIVE_FILTERS": true}` to enable native dashboard filters.                                                                                                                                                                                                             |
| **`superset_service_name`**               | "superset"                                          | Name of the systemd service to create for Superset. The role will create a unit file at `/etc/systemd/system/<name>.service`. By default this is "superset", resulting in a service named **superset.service**. You generally do not need to change this unless you plan to run multiple Superset instances on one host or want a custom service name. All role tasks/handlers reference this name variable, so it will consistently apply wherever used.                                                                                                                                                             |
| **`superset_marker_file`**                | "{{ superset_config_dir }}/.admin_created"          | Path to a marker file that indicates the admin account has been created. The role uses this file (by default `/etc/superset/.admin_created`) to track idempotence for the admin user creation task. If the file exists, the role will skip creating the admin again. You normally wouldn't change this path; it's simply a mechanism to ensure the admin creation runs only once.                                                                                                                                                                                                                                     |

</details>

Most default values are defined in **`roles/apache_superset/defaults/main.yml`**. You can override any of these variables in your playbook or inventory to suit your needs. For instance, **you must override sensitive defaults** like `superset_secret_key` and `superset_admin_password` (the provided defaults are insecure placeholders). Similarly, point `superset_database_uri` to your database of choice for production. Override variables by setting them in your play's `vars`, in group/host vars, or via Ansible Vault for secrets. This role will apply your overrides when templating the configuration and setting up the service.

## Tags

This role defines several Ansible tags that allow you to run or skip subsets of tasks:

* **`superset`** – A general tag applying to all tasks in this role (every task is tagged `superset` in addition to more specific tags). Use this tag to include or skip the entire role's tasks easily.
* **`superset_install`** – Tasks that install system dependencies and create the superset user/group are tagged with `superset_install`. This covers package installation (`apt` for libraries) and system account setup.
* **`superset_venv`** – Tasks involved in setting up the Python virtual environment and installing Superset and Python packages are tagged `superset_venv`. This includes creating the venv, upgrading pip, installing Superset, and any extra Python packages.
* **`superset_config`** – Tagged to tasks that generate configuration files or directories. In this role, that is primarily ensuring the config directory exists and templating `superset_config.py`.
* **`superset_db`** – This tag marks tasks related to database initialization and data loading. These tasks run Superset CLI commands to initialize the metadata DB, create the admin user, load examples (if enabled), and perform any role-based setup (`superset init`).
* **`superset_service`** – Tasks that set up or manage the systemd service for Superset carry the `superset_service` tag. This includes writing the systemd unit file, reloading systemd, and enabling/starting the Superset service.

Using these tags, you can selectively run parts of the role. For example, run with `--tags superset_config,superset_service` to apply configuration changes and restart the service without reinstalling packages, or use `--skip-tags superset_db` if you want to avoid re-initializing the database on a re-run. By default, if you run the whole role (no tag filtering), all tasks execute in a logical order.

## Dependencies

**No other Ansible roles are required** for this role to function. There are no external role dependencies listed in the meta (dependencies: `[]` in meta). All necessary setup (installing packages, etc.) is handled within this role.

However, there are some *prerequisites/assumptions*:

* **Ansible Collections/Modules:** This role relies on modules included in Ansible Core (>= 2.12), such as `ansible.builtin.apt`, `ansible.builtin.pip`, `ansible.builtin.systemd`, etc. Ensure you run it with a compatible Ansible version (2.12 or newer) so that these modules are available. (If using older Ansible, you might need the `community.general` collection for some modules like `pip`; with Ansible 2.12+, these are in core.)
* **Python and pip:** The target host should have Python 3 available. The role installs `python3-pip` via apt to ensure pip is present. This is used to create the virtual environment and install Superset.
* **Internet access:** The target host (or proxy) needs internet access to download packages from apt repositories and Python packages from PyPI. The role will fail if it cannot reach these package sources. If operating in a restricted environment, make sure to set up appropriate proxies or internal mirrors for apt and PyPI.
* **Database server:** If you plan to use an external database for Superset (PostgreSQL, MySQL, etc.), that database should be set up separately. This role does **not** install or configure the database server software. You may use the **postgresql** role (see Cross-Referencing) or another method to prepare a database and provide the URI (`superset_database_uri`). The role will handle database *setup within Superset* (migrations and user creation), but the database server itself must exist and be reachable.
* **Redis/Celery:** Similarly, if using Redis or another broker for caching or Celery, those services must be available. This role will not install Redis or RabbitMQ – it only configures Superset to use them if URLs are provided. You can deploy a Redis server via an appropriate role or play (not included in this role by default).

In summary, there are no hard dependencies on other roles or collections, but you should ensure the environment is prepared (supported OS, network access, and any external services like DB or cache as needed). The role's meta lists **no Galaxy role dependencies** and all required system packages are installed as part of the role's tasks.

## Example Playbook

To use this role, include it in an Ansible play targeting your Superset server(s). Below is a minimal example of a playbook that applies the role to a host (or group) and overrides some important variables:

```yaml
- hosts: superset_servers
  become: yes  # Ensure privilege escalation for package installs and configuration
  vars:
    superset_secret_key: "{{ vault_superset_secret_key }}"        # Securely set in Ansible Vault
    superset_admin_password: "{{ vault_superset_admin_password }}"# Secure admin password from Vault
    superset_database_uri: "postgresql://superset:{{ vault_superset_db_password }}@db01.example.com/superset"
    superset_redis_url: "redis://redis01.internal:6379/0"         # Using Redis for caching (example)
    superset_load_examples: false                                 # Skip loading example data in production
  roles:
    - apache_superset
```

**Notes:**

* We use `become: yes` because the role performs operations like installing apt packages and writing to `/etc/` that require root privileges.
* Sensitive values (`superset_secret_key`, `superset_admin_password`, database passwords) are referenced from `vault_...` variables. In practice, you should define these in an encrypted vault file or other secure storage. For example, `vault_superset_secret_key` might be defined in an encrypted group var file so that you don't expose secrets in plain text.
* The `superset_database_uri` in this example is pointed to a PostgreSQL database server (`db01.example.com`). Ensure that this database exists, and the user/password (`superset` / `vault_superset_db_password`) have appropriate permissions. The URI format shown is `postgresql://user:password@host:port/dbname`. Adjust according to your database (for MySQL, use `mysql://`, etc.). If you keep the default (SQLite), no external DB is needed, but again, SQLite is not recommended for production.
* We set `superset_load_examples: false` to avoid loading demo data. In a development or trial environment, you could set this to `true` (or run the `superset load_examples` command manually) to get sample charts and dashboards.
* After this play runs, you should be able to access Superset on `http://<host>:8088` and log in with the admin username/password you provided.

You can include this role alongside other roles in a larger playbook. For instance, you might have plays to set up the database and other components, then a play to deploy Superset. Ensure that the database (and Redis, if used) are deployed and configured **before** running the Superset role, so that Superset can connect to them during initialization.

## Testing Instructions

This role is equipped to be tested with **Molecule** (a framework for Ansible role testing) to verify that it works correctly in a clean environment. Molecule enables automated testing of the role by applying it to a temporary instance (e.g., a Docker container) and checking the results. We use the Molecule Docker driver with Debian/Ubuntu base images (matching the supported platforms) for testing.

To run tests for the **apache_superset** role:

1. **Install Molecule and its dependencies:** On your control machine (where you run Ansible), install Molecule and related tooling. For example, using pip:

   ```bash
   pip install molecule[docker] pytest testinfra
   ```

   Ensure you have Docker installed and running as Molecule will use it to create containers for testing.

2. **Prepare the role and dependencies:** If this repository has a requirements file or if you use Galaxy roles/collections, make sure those are installed. (For this role, there are no external role dependencies, but Molecule will need the Ansible collection modules if not already present. Running `ansible-galaxy collection install -r requirements.yml` if such a file exists is a good practice.)

3. **Navigate to the role directory:** Go to the directory of this role in the repository, for example:

   ```bash
   cd roles/apache_superset
   ```

   This assumes each role has its own Molecule scenario in its folder. (If the repository uses a central `molecule/` directory with scenarios, find the scenario for `apache_superset`.)

4. **Run Molecule tests:** Execute Molecule with the test command. The scenario name is likely the same as the role name (unless defined otherwise). For example:

   ```bash
   molecule test -s apache_superset
   ```

   This will do the following:

   * Build a fresh Docker container (using a Debian or Ubuntu image) for the test.
   * Run the "converge" step, which applies this role inside the container using a test playbook. The role will install Superset and all dependencies in the container.
   * Execute verification steps (using **Testinfra/pytest**) to check that the role did what it's supposed to. For instance, it may verify that the `superset` user exists, the virtualenv is created with Superset installed, the config file is in place with correct content, the systemd service file exists in `/etc/systemd/system/superset.service`, and that the service is running and listening on port 8088.
   * Finally, it will destroy the container.

5. **Review results:** If all tasks and tests pass, Molecule will output a success message (e.g., "OK" at the end of the run). If something fails, you'll see errors in the output. In case of failures, you can troubleshoot by running Molecule in stages:

   * Use `molecule converge -s apache_superset` to just apply the role without running tests. This leaves the container up for inspection.
   * Then use `molecule login -s apache_superset` to open a shell inside the test container. Here you can manually check the system – for example, run `systemctl status superset` to see if the service started, inspect logs with `journalctl -u superset`, check if the venv and files exist, etc.
   * You can also run `molecule verify -s apache_superset` separately to re-run the tests after convergence, once you think issues are fixed.

The Molecule tests help ensure the role is idempotent and that all components are configured correctly. Role contributors or maintainers should run these tests when making changes to catch regressions. The test scenario for this role (defined in `molecule/` directory) uses default variables, so it will by default test the SQLite setup. If you modify default variables (like changing the default port or service name), you might also need to update the tests accordingly (e.g., tests might assume port 8088 or service name "superset" unless changed).

## Known Issues and Gotchas

* **Insecure default credentials:** Out of the box, the role sets up an admin user with username "admin" and password "CHANGEME". Obviously, **these defaults are insecure** and meant only for initial testing. You **must override** `superset_admin_password` (and ideally the username or at least the secret key) for any non-testing deployment. Failing to do so will leave your Superset instance with a well-known password that anyone could use to gain full access. Always keep admin credentials secret (use Vault or inventory vars not in plain text). After the first run, if you need to change the admin password, you can either create a new admin via Superset's UI/CLI or rerun the role with updated `superset_admin_password` **and** remove the marker file (`/etc/superset/.admin_created`) so that the create-admin command runs again. (The marker prevents duplicate admin creation on re-runs.) Remember to restore proper permissions on that file if you recreate it.

* **SQLite database (default) is not suitable for production:** The default `superset_database_uri` uses a SQLite file for convenience. SQLite has limitations in multi-user, threaded environments – you may encounter errors or locks if multiple Gunicorn workers access it concurrently. It's fine for quick trials or single-user development, but in production you should use a robust database (PostgreSQL or MySQL are common choices). To do this, set `superset_database_uri` to the appropriate SQLAlchemy URI for your database. Ensure the database and user are created outside this role. The role will run migrations (`superset db upgrade`) on whatever database you point it to. If that database is not reachable or the credentials are wrong, **Superset will fail to start** (check the service logs for connection errors). This is a common pitfall: always double-check the URI string and network connectivity (e.g., firewall rules allowing the Superset host to contact the DB on the specified port). After switching from SQLite to another DB, you may need to manually migrate any data you entered in SQLite (if any) or just start fresh, as the two are separate database backends.

* **Initial startup and service state:** On the first run, after installation, the role starts the Superset service immediately. Superset might take some time (several seconds) to fully start up on first launch because it may apply migrations and load initial data. If you try to access the web UI *immediately* after the play finishes, you might get a 502/connection error until the service is ready. Give it a little time. You can watch `journalctl -u superset -f` to see the service logs in real time. If the service fails to start (e.g., exits unexpectedly), use `systemctl status superset` and logs to diagnose. Common causes include misconfiguration (as mentioned, DB or Redis not reachable, etc.) or missing Python dependencies (if you needed to include additional drivers in `superset_additional_python_packages` but didn't). Adjust variables and re-run the role if needed; it is idempotent and will correct the configuration and restart the service.

* **Port accessibility and firewall:** By default Superset listens on port **8088** on all interfaces (`0.0.0.0:8088`). This means the web interface will be accessible to anyone who can reach that port. In many setups, you'll want to restrict this. Consider one or more of:

  * Using a firewall (UFW, iptables, cloud security groups) to allow access to 8088 only from trusted networks (or not at all if behind a proxy).
  * Changing `superset_gunicorn_bind` to `127.0.0.1:8088` so that Superset only listens on the localhost interface. In this case, you'd likely put a reverse proxy (Nginx, Apache, or HAProxy) on the same host to proxy external requests to Superset, possibly adding TLS termination.
  * If you do expose 8088 directly, be aware it's HTTP by default (no SSL). All data including login credentials would be transmitted in cleartext. It's highly recommended to put Superset behind an HTTPS proxy if used over the public internet. This role does not configure HTTPS natively.
  * Ensure any existing web server on the host isn't already using port 8088, or change the bind port to something else to avoid conflicts.

* **Celery worker not started by role:** Superset has the capability to run background jobs (scheduled reports, async queries) using Celery workers. While this role sets the `CELERY_BROKER_URL` in the config if you provide one, it **does not automatically launch a Celery worker process**. The main Superset service (Gunicorn) does not spawn background workers itself – you need a separate service for that. We have provided a systemd unit template `superset-worker.service.j2` for a Celery worker, but the tasks in this role do **not** install or enable it by default. If you require Celery, you must take extra steps. For example, you can copy that template to `/etc/systemd/system/superset-worker.service` (similar to how the main service is set up) and then start `superset-worker` service on the host. Or, you could write an Ansible task to do this (consider using a modified version of this role or an additional small role). Failing to run a worker will mean functionalities like email reports or some long-running data imports won't work (those tasks will be queued but never processed). If you don't need any Celery tasks, you can ignore this. If you do, be sure to deploy the worker. (Also ensure the broker – e.g., Redis – is accessible and configured with proper credentials.)

* **Resource usage considerations:** Apache Superset (and its dependencies) can be resource-intensive:

  * **Memory/CPU:** Installing Superset via pip will pull in many Python packages (Flask, Pandas, Numpy, etc.). On systems with low memory, the pip install step might be slow or could fail if RAM is exhausted (especially if compiling some packages). The role includes `build-essential` and other libs to compile any needed extensions, but if you have <1GB of RAM, consider adding swap space before running, to avoid out-of-memory during installation.
  * **Running Superset:** The default Gunicorn config uses 4 worker processes. This is suitable for multi-core machines, but on a tiny VM you might reduce `superset_gunicorn_workers` to 2 or 1 to save memory. Each worker can consume tens of MB of RAM (or more, depending on usage). Monitor your system after deployment – if it's swapping or memory is tight, adjust accordingly.
  * **Storage:** By default, the metadata database (if using SQLite) will be stored in `/opt/superset/superset.db`. Ensure there is enough disk space and a backup strategy if this is important data. If using external DB, the concern shifts to that DB (make sure it's sized properly).
  * **Upgrading Superset:** When upgrading to a new Superset version (by changing `superset_version` and rerunning the role), be mindful that database migrations might run and the service will restart (causing a brief downtime). Always test new versions in a staging environment, and back up your metadata database before major upgrades. The role will handle the upgrade process (install new version, run migrations via `db upgrade`), but any custom config or data should be safeguarded. Also note that Python package upgrades can sometimes introduce new dependency requirements – the role's system packages list may need updates if Superset's dependencies change (for example, if a new driver needs an OS library). Stay updated with Superset's release notes.

* **Multiple Superset instances / scaling out:** This role is geared towards setting up a single Superset instance on a host. If you intend to scale out Superset (multiple server instances behind a load balancer), you'll need to consider a few things that the role itself doesn't fully cover:

  * All instances should use the same external metadata database (so they share dashboards, users, etc.).
  * Use a common `SECRET_KEY` across instances (so session cookies are valid on all).
  * Probably run with `superset_gunicorn_bind` on 127.0.0.1 and put a load balancer like **HAProxy** or **NGINX** in front on those hosts or externally. You can use the **ha_proxy_load_balancer_setup** role (see Cross-Referencing) to configure load balancing for multiple Superset backends.
  * Shared caching layer (Redis) is advisable so that all instances have a consistent view of cached data. Configure `superset_redis_url` accordingly, and ensure that Redis is accessible to all instances.
  * The role itself can be applied to multiple hosts (inventory group) to set up identical Superset instances, but coordination of the above points is up to your playbook design.

By being aware of these caveats and adjusting your configuration, you can avoid common pitfalls when deploying Superset with this role.

## Security Implications

Deploying Superset with this role has a few security considerations to keep in mind:

* **System user and permissions:** The role creates a dedicated `superset` user and group to run the application, with a shell of `/usr/sbin/nologin` (preventing interactive login). All Superset files (installation directory, config, virtualenv) are owned by this user/group, and the config directory `/etc/superset` is set to only be accessible by the Superset user and group (mode 0750). The config file containing secrets (`superset_config.py`) is set to mode 0640 (readable by superset and root, not world). These measures limit exposure of sensitive information (like the secret key and DB password) on the host. Only privileged users or the Superset service itself can read those values.

* **Secrets in configuration:** As noted, the `SECRET_KEY` and database credentials (if embedded in `superset_database_uri`) are critical secrets. **Do not leave the defaults** ("CHANGEME") in place. Use Ansible Vault or another secret management approach to supply strong secrets to this role. Treat the rendered `/etc/superset/superset_config.py` as sensitive. If using version control for your inventory, never commit real secret values. Rotate the `SECRET_KEY` only with caution: changing it will invalidate existing user sessions (which might be acceptable during maintenance windows).

* **Network exposure (ports and encryption):** Superset's web service by default does not use encryption – it's an HTTP server on port 8088. If deployed in an environment where untrusted users could sniff traffic, this is a risk (logins and data in transit are in plaintext). Mitigate this by:

  * Running Superset behind an HTTPS reverse proxy or load balancer. Offload TLS there.
  * Or at minimum, restrict access to the Superset port to trusted networks (firewall or binding to localhost and using an SSH tunnel/VPN for access).
  * Ensure that if you enable public access, all users have to authenticate (Superset by default requires login, but some features like public dashboards could be enabled – configure those carefully).
  * Optionally, consider configuring Superset with OAUTH/SAML for enterprise auth if needed (outside the scope of this role).

* **Firewalls and open ports:** After this role runs, port **8088** is open on the Superset host (listening). If you have a host-based firewall (like UFW) or cloud firewall, you'll need to explicitly allow traffic if you want users to reach Superset from outside. Conversely, if this host should not expose Superset publicly, make sure the firewall is configured to block 8088 or bind Superset to `127.0.0.1`. The role itself doesn't alter firewall settings, so it relies on your infrastructure's default. Always verify port status after deployment (e.g., using `ss -tulnp` to see listening ports and maybe `nmap` from another host to ensure it's appropriately reachable or not).

* **Superset admin access:** The first user created (admin) has full access to Superset, including the ability to execute database queries and upload data sources. Protect these credentials. If multiple people will administer Superset, consider creating separate admin accounts for traceability (this can be done via the Superset UI or CLI after initial setup). The role only creates one admin user. Make sure to change the password from the default immediately if you somehow deployed with the default.

* **Use of Celery and Redis:** If you configured `superset_celery_broker_url` or `superset_redis_url`, ensure those services are secured:

  * For Redis, use a strong password if it's not running in a trusted internal network, and restrict its access to the Superset hosts only. The URL format supports embedding a password (e.g., `redis://:password@hostname:6379/0`). The role will include whatever you set. Don't leave a Redis instance open to the world without auth – that could be misused.
  * If using RabbitMQ or others as broker, similar rules apply (use SSL/auth if appropriate).
  * The Celery tasks executed by Superset can potentially consume a lot of resources or access data; ensure that only authorized code runs (Superset's official Celery tasks are fine, but if you allow custom Python in charts or SQL Lab, consider the implications).
  * The role's omission of automatically starting a worker (see above) was partly to avoid running extra services without explicit user request. If you do start the `superset-worker` service, treat it with the same security as the main Superset service (runs as `superset` user, etc.). The provided `superset-worker.service.j2` uses the same user and directory for operation.

* **Elevated privileges during install:** The role uses `become: yes` for certain tasks (apt installs, file permission changes, systemd setup). This means the Ansible user needs sudo rights. The tasks are designed to limit scope (e.g., they don't run arbitrary commands beyond what's needed). Still, you should review the role (as you should any role) before running it in sensitive environments. Post-install, the Superset service runs as a non-root user, which is a good security practice.

* **Superset application security:** While beyond the direct scope of this role, note that Superset itself has security features (authentication, authorization roles for charts/dashboards, etc.). The role doesn't configure these beyond creating the admin. It's up to you to integrate with your auth systems (if desired) and assign roles to users. Keep Superset updated to get security fixes; you can update it by bumping `superset_version` and rerunning the role, as mentioned. Always test new releases.

In summary, this role tries to follow best practices (least privilege user, minimal file permissions, no open firewall by default). But it's crucial that you, as the operator, provide strong secrets and consider network security around the deployment. With proper configuration, Superset can be run securely in production.

## Cross-Referencing

This repository contains other roles that can complement or be used alongside **Apache Superset** depending on your infrastructure needs:

* **[base](../base/README.md)** – We highly recommend running the Base role on your servers before deploying Superset. The Base role ensures your system is up-to-date and hardened (unnecessary packages removed, automatic updates configured, fail2ban, etc.). Having that baseline increases security and reliability. Superset can be resource-heavy, so the Base role's optimizations (and ensuring latest system libraries) are beneficial. Superset assumes a functioning, secure base OS environment, which the Base role provides.

* **[postgresql](../postgresql/README.md)** – If you plan to use PostgreSQL as the metadata database for Superset (a common choice), the PostgreSQL role can set up a PostgreSQL server on a target host. You might use it to deploy a dedicated database server or to install PostgreSQL on the same host as Superset (for smaller deployments). After using the PostgreSQL role to set up the DB, update `superset_database_uri` in this role to point to the new database, and provide credentials. The PostgreSQL role documentation will have details on creating databases and users (ensure a database and user for Superset are created, and consider using `postgresql_allowed_hosts` or firewall settings if the DB is remote). Using PostgreSQL (or MySQL) is strongly recommended over SQLite for production Superset, and this role integrates with that by allowing the external DB connection.

* **[ha_proxy_load_balancer_setup](../ha_proxy_load_balancer_setup/README.md)** – For environments where you want to run multiple instances of Superset (for high availability or load distribution) or simply need a reverse proxy, the HAProxy role can be used. HAProxy could sit in front of one or more Superset application nodes, handling SSL termination and routing traffic to Superset's Gunicorn instances on port 8088. Even for a single instance, you might use HAProxy or another proxy for SSL. This role doesn't automatically inform HAProxy of its presence, but you can configure the HAProxy role to point to your Superset host(s) on port 8088. Refer to the HAProxy role docs for load balancing setup. (If you prefer Nginx/Apache as a reverse proxy, you may need to use a role from Ansible Galaxy or your own setup, as this repository's focus is HAProxy for load balancing.)

* **[apache_nifi](../apache_nifi/README.md)** – Apache NiFi is a data flow management tool. While not directly related to Superset, they often reside in the same ecosystem for data projects. If you are building a data platform, you might use NiFi to move and transform data, store it in databases or other systems, and then use Superset to visualize that data. The NiFi role can help deploy NiFi nodes. There's no direct integration between NiFi and Superset provided by the roles, but knowing it exists can help you orchestrate a pipeline (e.g., NiFi feeds data into a database, and Superset queries that database).

* **[minio](../minio/README.md)** – Minio provides S3-compatible object storage. Again, not directly used by Superset, but if your data visualizations rely on files or you want to store exports, Minio could be part of your stack. Superset itself doesn't interact with Minio out-of-the-box, but you might use Minio for storing backups of Superset metadata exports or to host static data for import. The Minio role can set up a storage server which might be relevant in a larger data infrastructure that includes Superset.

* **Amundsen Data Catalog roles** – If your organization is using **Amundsen** (data catalog by Lyft) in addition to Superset, note that this repository includes roles such as **amundsen_metadata**, **amundsen_search**, and **amundsen_frontend**. Superset and Amundsen are complementary (one for visualization, one for data discovery). They are not integrated by default, but you could deploy both and perhaps link from one to the other in documentation. The Amundsen roles set up a metadata service (with Neo4j and Elasticsearch) and a frontend. See those roles' READMEs for guidance. If running both Superset and Amundsen, ensure they don't contend for resources (both use Python/Flask backends) and adjust ports (Superset default 8088, Amundsen frontend maybe 5000 or 5001, etc., which should be fine).

* **Firewall and Security roles** – The Base role mentions an optional UFW (Uncomplicated Firewall) integration. While this repository doesn't have an active UFW role by default (it was planned and commented out in Base), you should consider using a firewall role or manual firewall configuration. If you require host-level firewalling, look at roles on Ansible Galaxy like `oefenweb.ufw` or the built-in `ufw` module in tasks. Locking down ports (e.g., only 22 and 80/443 open, etc.) is a good practice. Superset's role doesn't do this automatically to avoid assumptions, but nothing stops you from adding a simple task or role to manage UFW or iptables after deploying Superset.

Each of the above roles has its own documentation. Depending on your deployment, not all will be relevant. For a simple single-node Superset setup, you might only use Base, PostgreSQL, and this Superset role. In a larger data platform, you might deploy many components (database, NiFi, Minio, Amundsen, etc.) and have Superset as the BI layer on top. Use the roles that fit your architecture. The **apache_superset** role is designed to work independently, but it assumes that the foundational pieces (OS base config, database, etc.) are in place or managed by the appropriate roles as needed. By combining this role with others in the repository, you can build a full-featured and secure data environment.
