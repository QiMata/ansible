# Ansible Role: PostgreSQL

**Table of Contents**

* [Overview](#overview)
* [Supported Operating Systems/Platforms](#supported-operating-systemsplatforms)
* [Role Variables](#role-variables)
* [Extensions](#extensions)
* [Tags](#tags)
* [Dependencies](#dependencies)
* [Example Playbook](#example-playbook)
* [Testing Instructions](#testing-instructions)
* [Known Issues and Gotchas](#known-issues-and-gotchas)
* [Security Implications](#security-implications)
* [Cross-Referencing](#cross-referencing)

## Overview

The **PostgreSQL** role installs and configures a PostgreSQL database server on Debian/Ubuntu systems, with optional high-availability features (either streaming replication or a Patroni-managed cluster). It handles the full setup from package installation to configuration tuning, and can optionally open firewall ports and set up replication users.

**üî• NEW: Enhanced with Comprehensive Extensions!**

This role now includes powerful extensions for:
- **Monitoring & Observability** - Prometheus metrics, health checks, performance monitoring  
- **SSL/TLS Management** - Automated certificate handling, Let's Encrypt integration
- **Connection Pooling** - PgBouncer setup and configuration
- **Security Hardening** - Fail2ban, audit logging, enhanced authentication  
- **Performance Tuning** - Automated optimization based on system resources

Key tasks and features of this role include:

* **Package Installation:** Installs required OS packages and Python libraries (e.g. `gnupg`, `ca-certificates`, `python3-psycopg2`) and adds the official PostgreSQL APT repository (PGDG) if enabled. By default, it installs PostgreSQL **{{ postgresql_version }}** (15 by default, configurable) from the distribution‚Äôs repositories, or from PGDG when `postgresql_use_official_repo: true`.
* **Service Setup:** Installs the PostgreSQL server packages and ensures the database service is enabled and running. For a standard deployment, the PostgreSQL service (systemd unit) will be started. If Patroni is enabled (see below), the role instead sets up Patroni and disables the default PostgreSQL service.
* **Configuration Tuning:** Templates the PostgreSQL config files (`postgresql.conf` and `pg_hba.conf`) with sensible defaults. The role applies **environment-based tuning** via the `postgresql_env` variable: in **`prod`** mode, it sets higher memory and connection limits (e.g. `max_connections`, `shared_buffers`), whereas **`dev`** mode uses smaller, resource-saving values. It configures logging parameters (log collector, log directory, minimum duration for statements) and enforces secure password encryption (`scram-sha-256` by default). The `pg_hba.conf` is populated with default local access rules (peer auth for Unix socket, MD5 for localhost TCP) and can be extended via variables (see **Role Variables**).
* **Authentication and Users:** If a `postgresql_admin_password` is provided, the role will set the PostgreSQL *superuser* (`postgres`) password accordingly (using the `community.postgresql.postgresql_user` module). By default, the `postgres` account has no remote password and relies on peer authentication locally; setting a password allows remote admin connections (you should also adjust HBA rules for remote access). The role does **not** create additional databases or users by default (aside from replication; see next), so provisioning application databases/users should be done separately (e.g. via another task or role).
* **Streaming Replication (Optional):** When `postgresql_enable_replication: true`, the role can prepare the server for streaming replication. You designate one node as **primary** (`postgresql_replication_role: "primary"`) and others as **standby** (`postgresql_replication_role: "standby"`). On the primary, the role creates a replication account (default user **`replicator`**) with replication privileges. On standbys, it configures the `postgresql.auto.conf` to connect to the primary (`primary_conninfo`) so that replication can begin. The configuration sets `wal_level=replica`, `hot_standby=on`, and a default of 3 WAL senders (adjustable via `postgresql_max_wal_senders`). *(Note: The role does not handle the initial base backup of the primary‚Äôs data; see **Known Issues** below.)*
* **Patroni High-Availability (Optional):** If `postgresql_use_patroni: true`, the role will install and configure **Patroni** (an HA manager for PostgreSQL). It installs Patroni via pip and writes a Patroni YAML config (`/etc/patroni.yml`) with cluster settings (including an **etcd** endpoint, cluster name, node name, replication credentials, etc.). It also creates a systemd service for Patroni and disables the standard `postgresql` service. When using Patroni, the role expects an external etcd (or Consul/ZooKeeper) cluster available for distributed consensus (the address is set in `patroni_etcd_host`). Patroni will manage the PostgreSQL process, replication, and failover; the role‚Äôs handlers trigger Patroni restarts as needed after config changes. This option is suited for advanced deployments requiring automatic failover and cluster management.
* **Firewall Configuration (Optional):** When `postgresql_configure_firewall: true`, the role will adjust the host‚Äôs firewall to allow PostgreSQL access. It supports both **UFW** and **firewalld** ‚Äì if UFW is present (and selected by `postgresql_firewall_use_ufw: true`), it will add a rule to allow TCP port **{{ postgresql_port }}**. If instead `postgresql_firewall_use_ufw` is false (or UFW is not installed) and Firewalld is running, it opens the port in Firewalld. This helps ensure the database port is reachable to clients or replica nodes as needed. (By default, the port is **5432**, and no firewall rules are added unless explicitly enabled.)
* **Handlers and Idempotency:** The role defines handlers to **reload or restart PostgreSQL** when configuration files change (reload for standard PostgreSQL changes, full restart if Patroni is used or certain critical settings change). All tasks are written to be idempotent, so re-running the role will only make changes if configuration drifts or new options are set. This allows safe repeated applications, for example, to update settings or add replication after initial install.

In summary, applying this role results in a running PostgreSQL server configured with your chosen settings. You can use it for a standalone database server or as part of a multi-node cluster. Optional features (like replication and Patroni) can be enabled as needed to support more complex architectures. The role aims to provide secure defaults (local-only access in dev mode, strong password hashing, no open port unless requested) while still being flexible for production use.

## Supported Operating Systems/Platforms

This role is built for **Debian-based Linux distributions** and has been tested on the following 64-bit OS versions:

* **Debian** ‚Äì 11 (*Bullseye*) and 12 (*Bookworm*)
* **Ubuntu LTS** ‚Äì 20.04 (*Focal Fossa*) and 22.04 (*Jammy Jellyfish*)

> **Note:** These Debian/Ubuntu releases are the primary targets and assume the presence of APT, the `postgres` system user, and standard Debian/Ubuntu file paths. Other Linux distributions (e.g. RHEL, CentOS, AlmaLinux) are **not supported out-of-the-box** by this role. The tasks use APT package management and Debian-specific service names, so they will not work on RHEL-based systems without modifications. Adapting the role to Red Hat derivatives would involve using `yum`/`dnf` modules, different package names, and possibly different default paths (and ensuring `systemd` is present for service management). If you need to run on a non-Debian OS, consider using a different role or customizing this one for that environment.

All target systems must have Python 3 and systemd available (the role manages services via systemd). The role‚Äôs tasks assume a **systemd** init system and will not function on systems without it (e.g. containers or minimal installs lacking systemd). If testing in such environments, you may need to emulate or bypass service tasks.

## Role Variables

Below is a list of variables that can be used to customize the role‚Äôs behavior, along with default values (defined in **`defaults/main.yml`**) and descriptions. You should review these and adjust as necessary for your use case. Most defaults are suitable for a basic installation, but optional features (like replication, Patroni, or SSL) require setting the appropriate variables. Variables marked as **required** (with ‚Äú*Not set*‚Äù default) must be provided by the user when enabling those features.

<!-- markdownlint-disable MD033 -->

<details><summary>Role Variables (defaults)</summary>

| Variable                                    | Default Value¬†¬†                                                                                                                             | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| ------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **`postgresql_version`**                    | **`15`**                                                                                                                                    | **PostgreSQL major version** to install. This determines the package name (when using the official repo) and the default data directory path. You can set this to a supported version number (e.g. **14**, **15**, **16**). If `postgresql_use_official_repo` is **`false`**, the role will install the OS default PostgreSQL version (ignoring this variable). Changing this on an existing server does **not** automatically upgrade the data ‚Äì handle major version upgrades with care (see **Known Issues**).                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| **`postgresql_use_official_repo`**          | **`false`**                                                                                                                                 | Whether to enable the official PostgreSQL APT repository (PGDG). If **`true`**, the role adds the PGDG repo and its GPG key, allowing installation of the version specified in `postgresql_version`. If **`false`**, it uses the distribution‚Äôs default PostgreSQL packages (which may be older). Use this if you need a specific Postgres version not available natively on your OS.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| **`postgresql_apt_repo_url`**               | "deb [signed-by=/usr/share/keyrings/postgresql.gpg] http://apt.postgresql.org/pub/repos/apt {{ ansible_distribution_release }}-pgdg main" | The APT repository source line for the PGDG repository. This is the default upstream repository for PostgreSQL packages on Debian/Ubuntu. It is used only if `postgresql_use_official_repo` is enabled. Typically you should not need to change this, but you can override it to use a mirror or a different release if necessary (the placeholder `{{ ansible_distribution_release }}` will be replaced with your OS codename, e.g. ‚Äúbullseye-pgdg‚Äù).                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| **`postgresql_apt_repo_key_url`**           | `https://www.postgresql.org/media/keys/ACCC4CF8.asc`                                                                                        | URL of the official PGDG APT repository GPG key. The role fetches this key to trust the repository. If your environment is offline or you use an internal mirror, you may override this with a local key path or a different URL.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| **`postgresql_env`**                        | **`"prod"`**                                                                                                                                | Sets the general environment mode for the database configuration. Use **`"prod"`** for production-like systems (enables more robust settings and listening on all interfaces) or **`"dev"`** for development (lower resource usage and listen on localhost only). This affects several defaults in `postgresql.conf` (connections, memory) and `listen_addresses`. It does **not** change package installation or service behavior.                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| **`postgresql_data_dir`**                   | "/var/lib/postgresql/{{ postgresql_version }}/main"                                                                                       | Filesystem path for the PostgreSQL **data directory** (cluster directory). By default, uses the Debian/Ubuntu convention (e.g. `/var/lib/postgresql/15/main`). If you change `postgresql_version`, this path will automatically point to the corresponding version‚Äôs directory. Modify this if you want to initialize the database in a non-standard location; note that if changed after installation, you would need to migrate existing data to the new path manually.                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| **`postgresql_service_name`**               | **`"postgresql"`**                                                                                                                          | Name of the PostgreSQL service to manage. On Debian/Ubuntu, the service is named ‚Äúpostgresql‚Äù. If you run multiple clusters or use a custom service name, you can adjust this. This is also used to stop/disable the service when Patroni is enabled. In most cases, the default is correct and should not be changed.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| **`postgresql_port`**                       | **`5432`**                                                                                                                                  | The port on which PostgreSQL listens for connections. Default is 5432 (the standard PostgreSQL port). If you run multiple database instances on one host or need to avoid a conflict, you can change this. Ensure firewall settings (`postgresql_configure_firewall`) and client connection info (applications, etc.) are adjusted accordingly.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| **`postgresql_listen_addresses`**           | "*" (if env is `prod`)<br>`"localhost"` (if env is `dev`)                                                                                 | The network interfaces on which PostgreSQL will listen for connections (corresponds to `listen_addresses` in `postgresql.conf`). By default, in **prod** environment it listens on all interfaces (`*`) to allow external connections, whereas in **dev** it listens only on `localhost` for safety. You can override this to specific IPs (e.g. `"192.168.10.10"` or `"localhost,10.0.0.5"`). Be cautious: listening on `*` without proper firewall/HBA rules can expose the database to unintended networks.                                                                                                                                                                                                                                                                                                                                                                                             |
| **`postgresql_max_connections`**            | **`100`** (prod)<br>**`20`** (dev)                                                                                                          | The maximum number of concurrent connections to the database. Higher in prod mode (100) and lower in dev mode (20) by default. Tune this based on your workload and server resources. Keep in mind that each connection consumes memory; setting this too high on a small system can exhaust resources.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| **`postgresql_shared_buffers`**             | **`"1GB"`** (prod)<br>**`"256MB"`** (dev)                                                                                                   | Memory allocated for PostgreSQL shared buffers. Defaults to 1 GB in prod and 256 MB in dev. This setting greatly impacts performance; roughly 25% of system RAM is a common guideline for dedicated DB servers. Adjust according to your server‚Äôs RAM and performance needs.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| **`postgresql_work_mem`**                   | **`4MB`**                                                                                                                                   | Memory for internal sort operations and query work memory (per sort or join). The default 4 MB is conservative. In production, you might increase this if you have complex queries or sufficient RAM, but remember it‚Äôs per-operation and per-connection.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| **`postgresql_maintenance_work_mem`**       | **`64MB`**                                                                                                                                  | Memory for maintenance tasks like indexing and vacuum. Default 64 MB. You can raise this to speed up maintenance operations on large databases (for example, during index creation or vacuuming), especially if you perform those tasks during off-peak times.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| **`postgresql_effective_cache_size`**       | **`"3GB"`** (prod)<br>**`"768MB"`** (dev)                                                                                                   | An estimate of the filesystem cache available to PostgreSQL, which influences the query planner‚Äôs decisions. Default is 3 GB in prod mode, 768 MB in dev. Often set to ~50% of system RAM. This is not an actual memory allocation, just a hint to PostgreSQL‚Äôs optimizer.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| **`postgresql_logging_collector`**          | **`on`**                                                                                                                                    | Whether to enable the PostgreSQL logging collector. Default is `on` (enabled), meaning PostgreSQL will redirect logs to files (rather than only stdout). This works with `postgresql_log_directory` below. You might turn this off in container setups where stdout/stderr capture is preferred.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| **`postgresql_log_directory`**              | **`"log"`**                                                                                                                                 | Directory (within the data directory) where PostgreSQL will write log files when logging collector is on. By default, `"log"` which resolves to e.g. `/var/lib/postgresql/15/main/log`. You can change this to an absolute path for logs (ensure the postgres user has write permissions).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| **`postgresql_log_min_duration_statement`** | **`-1`**                                                                                                                                    | Sets the duration (in milliseconds) above which statements will be logged to the slow query log. **`-1`** means **disable** duration-based logging (no slow query log). You can set this to e.g. `1000` to log queries taking more than 1 second, which is useful for performance tuning.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| **`postgresql_password_encryption`**        | **`"scram-sha-256"`**                                                                                                                       | The algorithm for storing new passwords. Default is SCRAM-SHA-256 (the latest, more secure method introduced in PostgreSQL 10+). This means any password set (e.g. via this role‚Äôs user creation tasks or manually via SQL) will be stored as a SCRAM hash. If you need compatibility with very old clients, you might switch to `"md5"`, but it‚Äôs not recommended. This setting does not retroactively change existing passwords, only new or changed ones.                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| **`postgresql_hba_entries`**                | *(list, see defaults)*                                                                                                                      | A list of access rules for `pg_hba.conf`. By default, it includes: <br> ‚Äì Local Unix socket connections for user **postgres** (database `all`) and for **all** users to `all` databases, both with **peer** auth (no password, OS user must match).<br> ‚Äì IPv4 and IPv6 **localhost** connections for all users to all databases with **md5** (password) auth.<br> These defaults allow local and loopback access. You can override or extend this list to grant access to other hosts or networks. For example, to allow an app server at 10.0.0.100 to connect as a certain user, you might add an item: `{ type: 'host', database: 'mydb', user: 'myuser', address: '10.0.0.100/32', auth_method: 'md5' }`. The role will template all entries in the order given. Be careful to maintain secure settings (don‚Äôt inadvertently allow trust or passwordless access from untrusted networks). |
| **`postgresql_admin_password`**             | *Not set* (empty string)                                                                                                                    | Password for the **`postgres`** administrative user. By default, this is blank which means the role will **not** set a password, leaving the `postgres` user with peer-only access (no remote password). If you want to enable password authentication for the superuser, set this to a strong password (e.g. pulled from Ansible Vault). When provided, the role will run a task to update the postgres user‚Äôs password (using `ALTER USER ... PASSWORD`) with encryption. This allows you to then connect to the database as `postgres` remotely (provided your HBA and firewall permit it). **Important:** Store this secret securely (Vault) and update your HBA config to allow remote superuser access if needed (by default, remote connections for `postgres` are not allowed).                                                                                                                    |
| **`postgresql_enable_replication`**         | **`false`**                                                                                                                                 | Master switch to enable **streaming replication** setup tasks. If **`true`**, the role will include additional steps to configure replication (creating replication user, tweaking configs, etc.). You should also set `postgresql_replication_role` on each host (see below) to denote which servers are primary vs standby. This does not by itself turn on replication; it prepares the configuration and roles for it. You‚Äôll need to seed the standby server with data (e.g. base backup) outside of this role‚Äôs scope.                                                                                                                                                                                                                                                                                                                                                                               |
| **`postgresql_replication_role`**           | *Not set* (empty)                                                                                                                           | Role of this server in replication. Expected values: **`"primary"`** or **`"standby"`** (or leave undefined/empty if not using replication). This informs the role which replication tasks to run: on a **primary**, it will create/update the replication user; on a **standby**, it will configure the primary connection info. If you enable replication, set this for each host accordingly (e.g. in inventory or play vars). Standbys also require identifying the primary server (see `postgresql_primary_conninfo`).                                                                                                                                                                                                                                                                                                                                                                                |
| **`postgresql_replication_user`**           | **`"replicator"`**                                                                                                                          | The username for the replication role. The primary server will ensure this user exists with REPLICATION privileges. Standby servers will use this user to authenticate to the primary. You can change the name if desired (e.g. `"replica"`, `"pgrepl"`), but ensure it‚Äôs consistent across your inventory and matching any primary conninfo. This user is created with `LOGIN` and `REPLICATION` rights, and no superuser privileges.                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| **`postgresql_replication_password`**       | *Not set* (empty string)                                                                                                                    | Password for the replication user. **Required** if `postgresql_enable_replication` is true, to allow password authentication for replication connections. This password should be set to a strong value (store it securely). It must be the same on the primary and all standbys. The role will create or update the replicator user on the primary with this password (encrypted per PostgreSQL‚Äôs settings) and configure standbys to use it in `primary_conninfo`. If left empty, the role will skip creating the user or configuring primary_conninfo, effectively leaving replication incomplete.                                                                                                                                                                                                                                                                                                     |
| **`postgresql_replication_network`**        | *Not set* (empty string)                                                                                                                    | CIDR network from which standbys will connect for replication. If provided (e.g. `"10.0.0.0/24"` or `"192.168.5.10/32"`), the role will add a line to `pg_hba.conf` to allow the `postgresql_replication_user` to connect from that network for replication purposes. This is important for primary servers to accept standby connections. You should set this to the subnet (or host) that covers your standby node IPs. If not set, no replication-specific HBA entry is added, meaning standbys might be unable to connect unless you manually adjust HBA rules.                                                                                                                                                                                                                                                                                                                                        |
| **`postgresql_use_patroni`**                | **`false`**                                                                                                                                 | Enables the **Patroni** setup tasks. When **`true`**, the role will install Patroni and configure the node as part of a Patroni-managed cluster. Use this on all nodes that should be in the HA cluster (in conjunction with `postgresql_enable_replication: true`, since Patroni utilizes streaming replication under the hood). Patroni tasks include installing via pip, writing config, creating a Patroni service, and disabling the standard Postgres service. Ensure you also provide Patroni-specific variables like `patroni_etcd_host`, and set `postgresql_replication_user`/`password` and `postgresql_admin_password` (Patroni needs these credentials for cluster management).                                                                                                                                                                                                               |
| **`patroni_etcd_host`**                     | *Not set* (empty string)                                                                                                                    | The **etcd cluster endpoint(s)** for Patroni. Example: `"10.0.0.5:2379"` for a single etcd node, or a comma-separated list for multiple (Patroni will use this for leader election and storing state). This must be configured if Patroni is enabled, otherwise Patroni will not know where to connect for DCS. The role places this value in the Patroni config file. (If you use Consul or Zookeeper instead of etcd, you would need to adjust the Patroni config template accordingly ‚Äì by default this role is tailored to etcd.)                                                                                                                                                                                                                                                                                                                                                                      |
| **`patroni_cluster_name`**                  | **`"pg-cluster"`**                                                                                                                          | A name for your Patroni cluster. This is an arbitrary identifier used by Patroni to distinguish clusters in the DCS. All nodes in the same Postgres HA cluster should share the same cluster name. It‚Äôs mainly used as a namespace in etcd/Consul. The default `"pg-cluster"` is generic; you may change it to something descriptive if running multiple clusters.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| **`patroni_node_name`**                     | `{{ inventory_hostname }}`                                                                                                                  | The name of this node within the Patroni cluster. Defaults to the Ansible inventory hostname. It should be unique for each node. Patroni uses this for identifying members (e.g. in logs and DCS). Typically, you can leave this as is (inventory names are usually unique). If you need a custom naming convention, ensure each node sets this variable differently.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| **`postgresql_enable_ssl`**                 | **`false`**                                                                                                                                 | Whether to enable SSL for PostgreSQL connections. If **`true`**, the role will set `ssl = on` in `postgresql.conf` and configure the server to use the provided certificate and key files. **Important:** You must also provide `postgresql_ssl_cert_file` and `postgresql_ssl_key_file` (paths to your SSL certificate and private key) for the Postgres server. The role does *not* generate or obtain certs; it assumes you have those ready (e.g. from your CA or Let‚Äôs Encrypt). Enabling SSL without providing the files will prevent PostgreSQL from starting.                                                                                                                                                                                                                                                                                                                                      |
| **`postgresql_ssl_cert_file`**              | *Not set* (empty string)                                                                                                                    | Path to the SSL certificate file to use if SSL is enabled. For example, `/etc/ssl/certs/postgres.crt`. This should be an absolute path on the target host. The file should contain the server‚Äôs public certificate (and any intermediate CA chain if needed). Only used when `postgresql_enable_ssl: true`. Make sure the postgres user can read this file.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| **`postgresql_ssl_key_file`**               | *Not set* (empty string)                                                                                                                    | Path to the SSL private key file for the PostgreSQL server (if SSL is enabled). For example, `/etc/ssl/private/postgres.key`. Must be an absolute path and the key should be in PEM format. This key should **not** be passphrase-protected (Postgres needs to read it on startup without human intervention). Permissions on this file should be restrictive (e.g. `0600` owned by postgres). Provide this only when `postgresql_enable_ssl: true`.                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| **`postgresql_configure_firewall`**         | **`false`**                                                                                                                                 | Whether to manage the firewall to allow Postgres traffic. If **`true`**, the role will attempt to open the PostgreSQL port (defined in `postgresql_port`, default 5432) on the host‚Äôs firewall. It will use UFW or firewalld based on `postgresql_firewall_use_ufw`. If neither firewall is available, this has no effect. By default (false), the role won‚Äôt modify firewall settings. Enable this if you want the role to ensure the DB port is accessible to your application or replica servers.                                                                                                                                                                                                                                                                                                                                                                                                       |
| **`postgresql_firewall_use_ufw`**           | **`true`**                                                                                                                                  | Controls which firewall tool to use when `postgresql_configure_firewall` is true. **`true`** selects **UFW** (Uncomplicated Firewall), **`false`** selects **firewalld**. The role will check if the chosen firewall is present/active: it requires the `ufw` package for UFW or the `firewalld` service for firewalld. If the chosen one isn‚Äôt available but the other is, you may need to toggle this variable. Generally, set this according to your OS‚Äôs firewall: Ubuntu/Debian often use UFW, while some use firewalld.                                                                                                                                                                                                                                                                                                                                                                              |
| **`postgresql_allowed_hosts`**              | **`[]`** (empty list)                                                                                                                       | A list of client host addresses or subnets that should be allowed to connect. **Note:** This variable is not automatically used by the role‚Äôs tasks, but can be leveraged to inform your firewall or HBA configuration. For instance, you might set `postgresql_allowed_hosts: ["10.0.0.0/24", "192.168.1.100/32"]` to document which networks you expect to access the DB. You would still need to ensure these are reflected in `postgresql_hba_entries` or opened in the firewall. (Future enhancements to the role might integrate this variable to apply firewall rules more granularly.)                                                                                                                                                                                                                                                                                                             |

</details>
<!-- markdownlint-enable MD033 -->

**Notes:** In many cases, the defaults will suffice for a simple installation, but you should **securely set passwords** (e.g. `postgresql_admin_password`, `postgresql_replication_password`) in your inventory or via Ansible Vault if you enable those features. By default, no password is set for the `postgres` user (only local peer auth), and no replication will occur unless configured. Also, if enabling replication or Patroni, remember to adjust `postgresql_replication_role` per host and provide any necessary connection info (like `postgresql_replication_network` for HBA, and `patroni_etcd_host` for Patroni). The role does not automatically create application databases or users; you should create those (e.g. with the `community.postgresql.postgresql_db` and `postgresql_user` modules or a dedicated role) after the database server is up.

## Extensions

This role includes several powerful extensions that can be enabled independently:

### üîç PostgreSQL Monitoring (`postgresql_monitoring`)
- **Prometheus Integration**: postgres_exporter with custom metrics
- **Health Checks**: Automated monitoring with configurable alerts
- **Performance Monitoring**: Slow query logging and pg_stat_statements
- **Replication Monitoring**: Lag detection and slot monitoring

**Enable with:** `postgresql_monitoring_enabled: true`

### üîí SSL/TLS Management (`postgresql_ssl`)
- **Multiple Certificate Sources**: Self-signed, Let's Encrypt, or custom certificates
- **Automated Certificate Rotation**: Renewal and deployment automation
- **SSL-Only Mode**: Force encrypted connections
- **Client Certificate Authentication**: Enhanced security options

**Enable with:** `postgresql_ssl_enabled: true`

### ‚ö° Connection Pooling (`postgresql_pgbouncer`)
- **PgBouncer Integration**: Automated setup and configuration
- **Multiple Pool Modes**: Session, transaction, or statement-level pooling
- **Performance Optimization**: Connection limits and timeout tuning
- **Monitoring**: Built-in connection pool metrics

**Enable with:** `pgbouncer_enabled: true`

### üõ°Ô∏è Security Hardening (`postgresql_security`)
- **Fail2ban Protection**: Automated intrusion prevention
- **Audit Logging**: Comprehensive activity tracking with pgaudit
- **File Permissions**: Hardened filesystem security
- **Network Security**: Restricted access and firewall integration
- **Password Policies**: Complex password requirements

**Enable with:** `postgresql_security_enabled: true`

### üöÄ Performance Tuning (`postgresql_performance`)
- **Automated Tuning**: Resource-based configuration optimization
- **Environment Profiles**: Different settings for dev/staging/production
- **Memory Optimization**: Intelligent shared_buffers and work_mem sizing
- **Maintenance Automation**: Vacuum and analyze scheduling

**Enable with:** `postgresql_performance_enabled: true`

**Example Usage:**
```yaml
- hosts: postgresql_servers
  roles:
    - role: data_systems.postgresql
      vars:
        postgresql_monitoring_enabled: true
        postgresql_ssl_enabled: true
        pgbouncer_enabled: true
        postgresql_security_enabled: true
        postgresql_performance_enabled: true
```

## Tags

This role does **not define any task tags** in its tasks. All tasks will run by default whenever the role is invoked. (You cannot selectively skip or run subsets of this role‚Äôs tasks via Ansible tags at this time.) If needed, you can apply tags at the playbook level when including this role, but internally each task is untagged and executes every time the role runs.

## Dependencies

* **Ansible Version:** This role requires Ansible **2.15** or higher. It uses newer Ansible features (e.g. collections, modern modules) and syntax that may not be available in older versions. Using the latest Ansible is recommended to ensure compatibility.
* **Collections:** Ensure the following Ansible collections are installed on the control machine, as the role relies on modules from them:

  * **`community.postgresql`** ‚Äì Used for PostgreSQL-specific modules like `postgresql_user` (to set the password and manage users) and potentially others. For example, the role uses `community.postgresql.postgresql_user` to set the `postgres` password and create the replicator user. Install via: `ansible-galaxy collection install community.postgresql`.
  * **`community.general`** ‚Äì Used for general modules like `ufw` (firewall) and possibly `apt_key`/`apt_repository` (depending on your Ansible version). The role calls `community.general.ufw` to open firewall ports. Install via: `ansible-galaxy collection install community.general`.
  * *(The Ansible **posix** collection is used implicitly for the `firewalld` module if needed; this is typically included in Ansible by default. Ensure you have `ansible.posix` for firewalld management.)*
* **Python Libraries:** The managed host needs the PostgreSQL client library (Python **psycopg2**). The role will attempt to install **`python3-psycopg2`** via apt, so in most cases you don‚Äôt need to pre-install it. However, if your distribution packages it differently or you‚Äôre using a virtualenv, ensure that a PostgreSQL adapter is available for Ansible‚Äôs database modules. Similarly, the `pg_dump` utility is used by some external roles (like backup roles); the PostgreSQL server packages usually include it by default.
* **External Services:** If using **Patroni**, you must have an external **etcd** (or equivalent) service running and reachable. This role **does not** install etcd/Consul. You should set up an etcd cluster separately (or use a role for it) prior to running this role with `postgresql_use_patroni: true`. The etcd endpoint must be provided via `patroni_etcd_host`. Additionally, if Patroni is enabled, ensure DNS or hostnames are set such that each node can reach the others (Patroni will use the `name:port` in `patroni_etcd_host` and the node names for coordination).
* **No Role Dependencies:** There are no hard dependencies on other Ansible roles for this role to function. It is a self-contained role. (In the past, one might have used **geerlingguy.postgresql** for basic installs; this role is intended to replace that in this repository when advanced features are needed. You do not need geerlingguy.postgresql if you use this role, unless you prefer it for simpler setups.)
* **Database Setup:** While this role installs the database server, it does not create application databases or users beyond the default `postgres` (and replication user if enabled). If you are deploying an application like NetBox or Keycloak, you will need to create the app‚Äôs database and user. This can be done with ad-hoc tasks or using a dedicated role or playbook. (For example, in this repository‚Äôs playbooks, a separate step or use of `geerlingguy.postgresql` was used to set up databases for certain apps; you can continue to do that, or manually run `psql` commands/Ansible modules to create DBs after this role runs.)

## Example Playbook

Below is an example of how to use the `postgresql` role in an Ansible playbook. This example assumes you have two groups in your inventory: **`db_primary`** for the primary database server, and **`db_standby`** for a standby server. We will show the play for the primary server (which also sets up replication user), and mention the standby configuration in comments:

```yaml
- hosts: db_primary
  become: true  # run with privilege escalation to install packages and configure system files
  vars:
    postgresql_use_official_repo: true       # Use the PGDG repository for latest packages
    postgresql_version: 16                   # Install PostgreSQL version 16 (if available for OS)
    postgresql_env: prod                     # Use production settings (listen on '*', more resources)
    postgresql_enable_replication: true      # Enable streaming replication setup
    postgresql_replication_role: "primary"   # This host will be the replication primary
    postgresql_replication_password: "{{ vault_postgres_repl_password }}"  # replication user password (retrieved from Vault)
    postgresql_admin_password: "{{ vault_postgres_admin_password }}"      # set postgres superuser password (retrieved securely)
    postgresql_configure_firewall: true      # Open the PostgreSQL port on the firewall
    postgresql_firewall_use_ufw: true        # (assuming Ubuntu/Debian, use UFW to open port)
    postgresql_allowed_hosts: ["10.0.1.0/24"] # (Optional) document allowed subnet ‚Äì ensure HBA or firewall uses this
    postgresql_replication_network: "10.0.1.0/24"  # Allow standbys in 10.0.1.0/24 to replicate from this primary
  roles:
    - role: postgresql
```

In the above play, we target the **db_primary** host and configure it as a Postgres server. We‚Äôve enabled the official repository to get PostgreSQL 16, set the environment to prod, and turned on replication. We provide a replication password and designate this host as the primary. We also set a `postgresql_replication_network` to ensure the primary‚Äôs HBA allows the standby‚Äôs subnet to connect for replication. We open the firewall for the local subnet as well. The sensitive passwords (`vault_postgres_repl_password` and `vault_postgres_admin_password`) are presumed to be stored securely (e.g. in an Ansible Vault or external secret manager) rather than plaintext.

**Standby configuration:** To set up a standby, you would run the same role on a host in the **db_standby** group, with variables adjusted for a standby. For example, on the standby host(s) you might set:

```yaml
postgresql_enable_replication: true
postgresql_replication_role: "standby"
postgresql_replication_password: "{{ vault_postgres_repl_password }}"  # same password as primary
postgresql_primary_conninfo: "host=db-primary.example.com user=replicator password={{ vault_postgres_repl_password }}"  # optional explicit connection string
```

When `postgresql_replication_role: "standby"`, the role will configure the standby to connect to the primary. By default, it tries to use the first host in the inventory group `postgres_primary` as the primary address. In our example, if we add the primary host to an inventory group named `postgres_primary`, the standby will automatically pick up its address. Alternatively, as shown, you can define `postgresql_primary_conninfo` explicitly with the primary‚Äôs hostname/IP and credentials. **Note:** Before starting the standby, you must ensure it has an initial copy of the primary‚Äôs data (e.g., use `pg_basebackup` to copy the database cluster). This role does not perform that step (see **Known Issues and Gotchas**).

Typically, you would include the `postgresql` role in your larger site playbook or in a database setup play. For instance, you might have a play for `db_primary` (as above) and another for `db_standby` hosts. Ensure the primary is configured and running before bringing up the standby. If using Patroni, you would set `postgresql_use_patroni: true` on all DB hosts and Patroni will handle initialization (the sequence of bringing up nodes differs in that case; refer to Patroni docs for cluster bootstrap procedure).

## Testing Instructions

It is recommended to test this role using **Molecule** (with the Docker driver) to verify that it works as expected in an isolated environment. This ensures that changes to the role don‚Äôt break the PostgreSQL setup. Follow these steps to run a local Molecule test of the role:

1. **Install Molecule and dependencies:** On your development machine, install Molecule and the Docker driver (and optionally Testinfra for verifications). For example, use pip:

   ```bash
   pip install molecule molecule[docker] docker-py testinfra
   ```

   Ensure you also have Docker installed and running, as Molecule will use it to create containers.

2. **Prepare a test scenario:** This role may come with a predefined Molecule scenario (e.g. under `roles/postgresql/molecule/default`). If a scenario is provided, you can use it directly. Navigate to the scenario directory:

   ```bash
   cd src/roles/postgresql/molecule/default
   ```

   *(If no Molecule scenario is included with the role, you can create one using `molecule init scenario -r postgresql -d docker`, which will set up a basic scenario directory.)* In the scenario‚Äôs configuration (usually `molecule.yml`), ensure the Docker base image matches one of the supported OS (e.g. Debian 12 or Ubuntu 22.04) for a realistic test. The default scenario, if present, typically uses a Debian image.

3. **Configure scenario (if needed):** Open the Molecule scenario‚Äôs `converge.yml` playbook. It should include the `postgresql` role, but you may need to provide necessary variables. For a simple test, you might set `postgresql_use_official_repo: false` (to use the OS default Postgres) or true (to test adding the repo), and perhaps a `postgresql_admin_password` to verify the password setting. If you want to test replication or Patroni in Molecule, you could set those vars and potentially spin up multiple containers (advanced). By default, a single-container test can verify a basic install.

4. **Run the Molecule test:** Execute Molecule to run the role in the container:

   ```bash
   molecule test
   ```

   This will perform the create, converge, and verify steps automatically. Molecule will launch a Docker container, apply the role, and then (if configured) run any verification steps (e.g. using Testinfra to check if PostgreSQL is running and listening on port 5432, etc.), then destroy the container. You should see output from Ansible showing the role tasks being executed. Ensure there are no errors or failed tasks.

5. **Review results:** After `molecule test` completes, check the output. If Testinfra tests are defined, see that they all passed. If no explicit tests are defined, you might manually verify by logging into the container (Molecule usually prints the container name) and ensuring that PostgreSQL is installed, the service is running, and configuration files reflect your variables. For example:

   ```bash
   docker exec -it <container_id> psql -U postgres -c "SELECT version();"
   ```

   should connect to the Postgres server and show the version. You can also verify that the config files in `/etc/postgresql/` or the data directory have the expected settings.

6. **Iterate if needed:** If the role didn‚Äôt behave as expected, you can adjust the role or scenario and re-run `molecule converge` (to apply changes without destroying the container) for debugging. Molecule is great for rapidly testing changes. Once satisfied, destroy the test environment with `molecule destroy`.

By using Molecule, you can confidently test changes to this role (like introducing new variables or supporting a new OS version) before applying it to real servers. This is especially useful for complex features like replication or Patroni ‚Äì you can simulate a multi-node environment with multiple Molecule instances or simply validate that the role tasks run without errors on a fresh system.

## Known Issues and Gotchas

* **No Automatic Base Backup for Replication:** While the role sets up configuration for streaming replication, it **does not perform the initial data sync** for standby servers. You must manually or separately handle the base backup. For example, after the primary is up, you might run `pg_basebackup` on the standby to clone the primary‚Äôs data directory (or use other backup/restore methods) before starting PostgreSQL on the standby. If you skip this step, the standby will have an empty data directory and will not be able to start replication properly (it will error out because it has no baseline data). Always ensure the standby‚Äôs data directory is a copy of the primary‚Äôs data (or use Patroni which automates this) before expecting replication to work.
* **Inventory Configuration for Replication:** By default, the role assumes an inventory group named **`postgres_primary`** to discover the primary host‚Äôs address for replication configuration on standbys. This means in your Ansible inventory you should define a group `postgres_primary` with the primary node (even if it‚Äôs also in another group). The standby tasks will use `groups['postgres_primary'][0]` as the primary‚Äôs hostname/IP in the `primary_conninfo`. If you do not use this group, you **must** set `postgresql_primary_conninfo` manually to tell the standby how to reach the primary. Forgetting to do either will result in a standby configured with a blank or incorrect primary connection string. Double-check your inventory or provide the variable to avoid this pitfall.
* **Replication User Password Required:** When enabling replication, you must set a `postgresql_replication_password`. If this is not provided, the role will skip creating the replication user on the primary and will not populate the standby‚Äôs `primary_conninfo` with a password, leading to authentication failure. In other words, **replication won‚Äôt work without a password** (the role assumes password-based auth for replication). Always define a secure replication password in your group vars or playbook vars when `postgresql_enable_replication: true`. This same warning applies to **Patroni**: the replication user and password are critical for Patroni‚Äôs configuration. Patroni will also require the superuser password (`postgresql_admin_password`) to be set, because it needs it for certain administrative actions (if not set, Patroni might fail to bootstrap or you‚Äôll have missing credentials in the Patroni config).
* **Patroni Considerations:** Using Patroni introduces additional requirements and caveats:

  * Make sure the `patroni_etcd_host` is correctly set to your etcd cluster‚Äôs address. If this is wrong or left empty, Patroni on each node will not be able to coordinate and will likely fail to start properly.
  * All nodes that have `postgresql_use_patroni: true` should be part of the same cluster (same `patroni_cluster_name`) and should be able to communicate with the etcd service and with each other on the Postgres port. Ensure network connectivity and firewall settings are in place (the role opening port 5432 via UFW/Firewalld on each node may be necessary so they can accept connections from other nodes).
  * **Patroni Config Security:** The Patroni configuration file (`/etc/patroni.yml`) contains the Postgres superuser password and replication password in plain text. By default, this file is written with mode 0644 (readable by all users). This is a potential security issue (see **Security Implications**). You may want to manually restrict this file‚Äôs permissions to root or postgres-only (e.g. 0600) after the role runs, or modify the role to template it with stricter permissions. As is, be aware that any local user on the server could read the Patroni config and obtain the database credentials.
  * When first setting up Patroni, you typically bring up one node, initialize the cluster, then bring up additional nodes. The role does not orchestrate the bootstrap sequence ‚Äì you might need to initialize the first node manually or ensure one node is labeled as initial (Patroni documentation covers this). All nodes will attempt to register with etcd; the first one up will create the cluster in etcd. Just keep this in mind during your deployment order.
* **Firewall Rules and Host Access:** The `postgresql_configure_firewall` option will open the database port, but it doesn‚Äôt discriminate among sources by default (UFW rule is broad unless your UFW default or other rules restrict it). If you want to limit which hosts or networks can access PostgreSQL, you should combine firewall settings with specific rules or use external firewall management. For instance, you might manually add UFW rules that allow only certain IPs if the role‚Äôs generic allow is too open. Additionally, even if the port is open, the **pg_hba.conf** entries ultimately control who can log in. By default, this role‚Äôs HBA config only allows local and loopback connections (and replication from `postgresql_replication_network` if set). If your application server is on a different host, you **must** add an appropriate HBA rule to allow it (e.g. in `postgresql_hba_entries`). Failing to do so will result in connection attempts being refused by PostgreSQL even if the firewall is open. In summary: open firewall + proper HBA entry are both needed for external access. On the other hand, if you leave `postgresql_env` as ‚Äúprod‚Äù (listen on `*`) and don‚Äôt enable the firewall or restrict HBA, you could accidentally expose Postgres to the world. Always verify that either the firewall or HBA (or both) limit access to trusted sources.
* **Upgrading PostgreSQL Version:** Changing the `postgresql_version` variable on an already-provisioned server will install the new version‚Äôs packages (especially if using the official repo), but **will not automatically upgrade your database data** to the new version. PostgreSQL major versions require a dump-and-restore or in-place upgrade (e.g. using `pg_upgrade`). The role doesn‚Äôt handle that process. If you simply change `postgresql_version` and rerun the role, you might end up with two versions installed side-by-side (e.g. PostgreSQL 15 and 16 both present) or the new version‚Äôs service not using the old data. Handle upgrades carefully: you may need to perform a dump/restore, use the `postgresql_upgrade` module or manual steps, or run the old and new versions in parallel and migrate. Always test the upgrade procedure in a non-production environment. The safest approach is often to set up a new server with the new version and migrate data to it, rather than in-place upgrades.
* **RedHat/CentOS Not Supported:** (Reiterating from **Supported OS**): If you attempt to run this role on a RHEL-based system, it will fail or do nothing useful, because it‚Äôs using apt and Debian paths. This is by design to focus the role. Use an alternative role for RHEL systems or fork this one and modify tasks appropriately. Trying to use this role as-is on the wrong platform will result in task failures (e.g. apt module not found on CentOS) or missing service definitions.
* **Idempotency and Re-runs:** Generally, the role is idempotent, but some edge cases to note: If you toggle `postgresql_use_official_repo` from false to true on an existing system, you‚Äôll add the new repo and potentially get a new PostgreSQL package from PGDG. However, if the distribution‚Äôs package was already installed (e.g. version 13 from Ubuntu, and you switch to PGDG 15), apt might install 15 alongside 13 (Debian/Ubuntu allow multiple versions). The role will start the default service (likely still the old version unless you manually adjust alternatives). In such cases, you may need to purge old packages or manually ensure only one version is running. Likewise, enabling Patroni on a system that was previously running Postgres directly will stop the `postgresql` service and start Patroni; any existing data directory will be taken over by Patroni. This should be fine, but be aware of the change in control mechanism. It‚Äôs best to decide on using Patroni upfront, or be prepared for a brief database downtime while switching.
* **SELinux and AppArmor:** This role doesn‚Äôt explicitly address SELinux or AppArmor profiles. On Debian/Ubuntu, AppArmor may restrict `postgres` in some ways (usually not an issue for the default setup). On RHEL (if one tried to adapt this role), SELinux would need proper context settings for data directory and ports. If you have security modules active, ensure that the rules allow PostgreSQL to bind to the chosen port and read the chosen data directory, etc. (For example, if you changed `postgresql_data_dir`, AppArmor might block access until policies are updated.)
* **SSL Setup:** If you enable SSL (`postgresql_enable_ssl: true`), note that the role does not copy or generate certificates. You should provision the `postgresql_ssl_cert_file` and `postgresql_ssl_key_file` on the server beforehand (e.g. use another role or a task to fetch them from a secure source). The Postgres server will refuse to start if SSL is enabled but the files are missing or have wrong permissions. Also, ensure the key file is owned by the `postgres` user and not world-readable (preferably 0600). This is a manual step by design, as certificate management is environment-specific. Also be aware that enabling SSL doesn‚Äôt automatically enforce its use; clients can still connect without SSL unless you set `ssl=on` and also configure `pg_hba.conf` rules to require SSL (the role does not add such rules by default).
* **Client Connection and Timeouts:** The default configuration is tuned conservatively. If you have a high-concurrency environment, you might need to adjust settings like `max_connections`, `max_wal_senders`, or memory parameters. Similarly, the role doesn‚Äôt set parameters like statement timeout or vacuum settings beyond basics. Be mindful to configure those as needed for your workload (either by extending the template or via `ALTER SYSTEM` after deployment).
* **Data Safety:** Always back up your data, especially when making changes to configuration or versions. This role can be used in conjunction with backup roles (see **Cross-Referencing** below) to ensure you have dumps or snapshots. For example, if running in production, test your restoration procedure if you‚Äôre using replication or Patroni ‚Äì understand how to rebuild a failed primary either via backup or Patroni‚Äôs mechanisms. The role by itself doesn‚Äôt guarantee data redundancy beyond what replication (or Patroni) provides at runtime.

## Security Implications

Deploying a database server has inherent security considerations. This role tries to encourage secure configurations (like using scram-sha-256 passwords and not opening ports by default), but it‚Äôs important to understand and address the following:

* **Privilege Use:** This role performs many tasks with **elevated privileges**. It runs package installations, file templates, and service management as **root** (Ansible `become: true` on tasks) and even switches to the **postgres** OS user for certain actions (like creating users in the database). Ensure that only trusted administrators run this role/playbook, as it has the ability to modify critical system files. Also, protect your inventory and variable files (especially those with passwords) since a compromise there could lead to unauthorized DB access.
* **Superuser Account (`postgres`):** By default, the `postgres` database user can only log in via local socket (peer auth) or local TCP with md5 (and since no password is set initially, effectively it‚Äôs local-only). This is a secure default as it prevents remote logins for the superuser. If you choose to set a `postgresql_admin_password` to enable remote admin, be aware that the superuser account becomes accessible over the network (if HBA allows it). Use a strong, random password and consider restricting `postgres` logins to specific IPs in `pg_hba.conf`. In many cases, it‚Äôs better practice to leave the `postgres` account for local administration and create lesser-privileged roles for remote access.
* **Passwords and Secrets:** All passwords (for the postgres user, replication user, etc.) should be treated as sensitive secrets. **Do not store them in plain text** in your playbooks or inventory. Use Ansible Vault or an external secrets manager. In our examples, we referenced `vault_postgres_admin_password` and `vault_postgres_repl_password` ‚Äì indicating these values should be pulled from a secure vault. Compromise of these credentials can lead to full control over your database. Additionally, the Linux `postgres` user (the system account) by default has no Linux password and is not meant for login ‚Äì do not set a password on it or use it for anything other than running the service.
* **Listening Address (`*`):** In production mode, PostgreSQL will listen on all interfaces (`0.0.0.0` and `::`). While convenient, this means the server will accept connection attempts from any network reachable host. It is crucial to combine this with proper **firewall rules** and **pg_hba rules** to only allow trusted sources. If you leave the port open and HBA allows a broad range (e.g. `host all all 0.0.0.0/0 md5`, which we **do not** do by default), you are risking unauthorized access. Always verify that only the necessary hosts/networks can reach the database. Using `postgresql_allowed_hosts` as a reference and configuring your firewall accordingly is advisable. If you want belt-and-suspenders security, you can also leave `postgresql_listen_addresses` as "localhost" and use SSH tunneling or stunnel for remote access, though that‚Äôs more complex.
* **Firewall & Network Security:** If `postgresql_configure_firewall` is enabled, the role opens the port, but as noted, it doesn‚Äôt specify source IPs. Make sure your overall firewall policy (default deny inbound, etc.) is in effect so that the allowed rule doesn‚Äôt inadvertently expose the port globally. If using UFW, typically the default is to deny incoming, which is good ‚Äì then the added rule will allow from anywhere by default. Consider editing that rule post-run to restrict to a certain IP or using UFW‚Äôs `from` parameter manually. On cloud environments, also ensure that security groups or cloud firewalls are configured to limit access (the role only configures the host‚Äôs local firewall).
* **Replication and Patroni Security:** Replication traffic by default is unencrypted (unless you enable SSL). If your replication is over a private network, that may be acceptable. For higher security, consider enabling SSL and having the replication user connect over SSL. Patroni‚Äôs API (by default listening on 127.0.0.1:8008) is not exposed externally in this role‚Äôs default config (which is good, as it has an admin endpoint). We use the replication user for Patroni REST API authentication ‚Äì which means someone who can access the Patroni REST API (on localhost by default) with those credentials could trigger failovers. By keeping it bound to localhost, we mitigate external access. If you change Patroni‚Äôs REST API to listen on a network interface (for e.g. haproxy health checks), be sure to set up authentication (as we did) and consider a firewall or trust source.
* **File Permissions:** The role templates certain files with specific permissions:

  * `postgresql.conf` (644, owned by postgres:postgres) and `pg_hba.conf` (600, postgres:postgres). These are appropriate defaults ‚Äì HBA is sensitive and thus 600, conf is less sensitive (though could reveal configuration). It‚Äôs fine as is.
  * `patroni.yml` (644, owner postgres) ‚Äì as discussed, contains sensitive info. Consider manually chmod to 600 as a hardening step.
  * The data directory (`postgresql_data_dir`) inherits permissions from package initialization (typically postgres:postgres 700). This is good ‚Äì ensure it stays that way if you migrate or copy data. Never give other users access to the data directory.
  * If you changed `postgresql_log_directory` to somewhere outside the data dir, check that directory‚Äôs permissions (by default, if it‚Äôs inside the data dir, it‚Äôs covered by the 700 on the data dir).
  * Backup files (if you use the backup roles referenced later) should also be protected; not directly this role‚Äôs scope but worth mentioning.
* **Patroni Config Exposure:** We want to re-emphasize the Patroni config issue here: **any local user can read the Patroni YAML and see the passwords** by default. This is a security trade-off (ease of reading config vs secrecy). In a controlled environment, perhaps only admins have shell access anyway. But on a multi-user system, this could be problematic. Adjust permissions to restrict access to that file (e.g., `chown root:postgres /etc/patroni.yml` and `chmod 640` or `600`). Patroni runs as postgres (according to the systemd unit we set), so it should still be able to read a 640 file owned by postgres. You could even set the Ansible task to template it with `mode: "0640"` for better security.
* **Data Encryption:** This role does not set up disk encryption for the data directory. If your threat model requires it, consider using OS-level full-disk encryption or filesystem encryption for the partition holding `/var/lib/postgresql`. PostgreSQL does support Transparent Data Encryption in some forks or upcoming features, but not in the versions targeted by this role. Rely on OS measures if needed.
* **Auditing and Logging:** By enabling the logging collector and directing logs to a file, you ensure that connections and errors are logged. You might want to adjust `log_min_duration_statement` to catch slow queries or set `log_connections`/`log_disconnections` for auditing purposes. The role doesn‚Äôt enable those by default, but you can via extra configuration if needed for security auditing.
* **Maintenance and Updates:** Keep your PostgreSQL server updated with security patches. If using the PGDG repository, you will get updates for minor versions (which include security fixes). Make sure to apply updates (via apt upgrade) regularly. The Ansible role itself doesn‚Äôt periodically upgrade Postgres once installed; that‚Äôs an admin task or could be part of an overarching playbook.
* **Limiting Access and Resource Use:** Consider using PostgreSQL‚Äôs own security features: create least-privilege roles for your applications (avoid using superuser for app connections), use roles and GRANTs properly, and consider enabling features like `pg_hba` rule to require client certificate authentication if that suits your needs. These are beyond what the role does, but important for a production-grade secure setup.

By understanding these implications and taking appropriate measures (strong passwords, Vault usage, firewalling, least privilege, secure defaults), you can safely deploy PostgreSQL with this role. Security is a shared responsibility: the role lays the groundwork, but how you configure and use the database will determine the overall security posture.

## Cross-Referencing

This PostgreSQL role is part of a suite of Ansible roles in this repository, and it can be used in combination with several others to build a full infrastructure. Here are some related roles and how they might interact with **`postgresql`**:

* **`netbox` role** ‚Äì Deploys the NetBox application (a data center inventory web app). NetBox requires a PostgreSQL database but the `netbox` role itself doesn‚Äôt install one (it assumes one is available and you provide the connection info). You can use the `postgresql` role to set up the database server for NetBox. For instance, run this `postgresql` role on a host (or group) that will serve as the NetBox database, create a database and user for NetBox (via Ansible tasks or manually), then run the `netbox` role pointing it at that database. The `backup_netbox` role (see below) can then be used to back up that data. In earlier usage, the community **geerlingguy.postgresql** role was used for a basic setup, but this `postgresql` role provides a more comprehensive solution (especially if you need replication or tuning).
* **`keycloak` role** ‚Äì Installs the Keycloak IAM server. Like NetBox, Keycloak needs a PostgreSQL database but doesn‚Äôt set it up itself. You can use this `postgresql` role to provision a database for Keycloak. For example, run the `postgresql` role on your database server (or Keycloak host if using local DB), and create a `keycloak` database and user. The Keycloak role can then be configured to use that DB (via variables `keycloak_db_host`, etc.). If you have a dedicated DB server for Keycloak, apply `postgresql` to that server. This role ensures PostgreSQL is up and tuned, while Keycloak role ensures the application is configured to connect to it.
* **`backup_netbox` role** ‚Äì Automates backups of a NetBox instance‚Äôs data (PostgreSQL dump and media files). If you are using NetBox with a PostgreSQL database set up by this role, the **backup_netbox** role can be applied on the NetBox server (or DB server) to periodically dump the NetBox database. In such a setup, ensure the `postgresql` role has created the NetBox database and user, and that the backup role has the credentials to connect. The backup_netbox role uses `pg_dump` and requires the `community.postgresql` collection (which you‚Äôll already have for this role). It‚Äôs complementary: `postgresql` role sets up the database, `netbox` role sets up the app, and `backup_netbox` safekeeps the data.
* **`postgres_backup` role** ‚Äì A general PostgreSQL backup role (also in this repository) for backing up databases via cron/systemd jobs. Unlike `backup_netbox`, which is app-specific, **postgres_backup** can be used to schedule dumps of any PostgreSQL database on a server. If you have a production DB server set up with the `postgresql` role, you might apply `postgres_backup` on that server to nightly dump the databases to files. It installs a script and a systemd timer to export the DB using `pg_dump`. Using `postgresql` (to set up the DB) together with `postgres_backup` (to back up the DB) gives a fuller solution. For example, if you have multiple applications using one Postgres server, use `postgresql` role to set it up, and then `postgres_backup` to back up all or specific databases regularly. Both roles rely on the **community.postgresql** modules for database access, and you should ensure the backup role has access credentials (which might mean setting up `.pgpass` or providing the user/password for the target DB in that role‚Äôs vars).
* **`haproxy` role** ‚Äì If you are setting up a **Patroni** cluster for high availability, you might also consider using a load balancer like **HAProxy** to direct client traffic to the current primary. The repository includes an **haproxy** role that can be configured to front a Postgres cluster. For instance, if you have three nodes with Patroni, you could deploy haproxy on them or a separate node to always forward connections to the leader (Patroni can output the leader‚Äôs status via its API for haproxy to use). While not strictly required (applications can also use multiple host connections or Patroni‚Äôs etcd to discover leader), haproxy can simplify client configuration by offering a single endpoint. The haproxy role can be set up to check Patroni‚Äôs API (on port 8008) for leader and route accordingly. This goes beyond the basics, but it‚Äôs worth noting as part of a resilient architecture.
* **`ufw` role / Base hardening roles** ‚Äì Although this `postgresql` role can open the firewall for you, some environments prefer to manage firewall rules globally. If you have a **base** role or a dedicated **ufw** role in the repository (there might be a role for setting up Uncomplicated Firewall on servers), you could choose to leave `postgresql_configure_firewall` false and instead use that role to open ports. Similarly, a base hardening role might ensure only certain ports are open system-wide. Coordinating with such roles ensures you don‚Äôt have conflicting firewall settings. The base role might also handle updates, user accounts, etc., which indirectly improves the security and reliability of the database host.
* **Application Roles (Jenkins, etc.):** If you deploy other applications like **Jenkins**, **Superset**, **Grafana**, etc., some of them might also use databases (though many use MySQL or their own internal DBs). This `postgresql` role is specifically for PostgreSQL. For any app in this repository that requires Postgres, you would use this role to set up the DB. For apps that use MySQL/MariaDB, there might be a separate role (e.g. `mariadb` or so). Always check an application role‚Äôs documentation to see what it needs. For those needing Postgres, this role is your go-to solution within this repo.
* **External Role Integration:** In case you still choose to use external roles for database setup (like the community **geerlingguy.postgresql** role), ensure that you don‚Äôt overlap them on the same hosts with conflicting settings. It‚Äôs generally not recommended to mix two roles that both install/configure PostgreSQL on the same host. Instead, decide on one approach. That said, you might use geerlingguy.postgresql for simpler cases and reserve this `postgresql` role for more complex setups (with replication/HA). This repository‚Äôs playbooks historically used geerlingguy for basic DB installs and could transition to using this role for advanced scenarios.

Each role has its own README and variables (as you can see). It‚Äôs useful to read those for details. By combining roles, you can orchestrate full-stack deployments. For example, a **site playbook** might include: set up base OS (users, firewall) -> setup PostgreSQL (this role) -> setup Redis (another role) -> setup NetBox (app role) -> setup backup roles, etc. The cross-referenced roles above are designed to complement each other. In particular, this `postgresql` role provides the backbone for any service requiring a Postgres database, while the backup roles ensure data safety, and the application roles (NetBox, Keycloak, etc.) build on top of the database services provided.

